#!/usr/bin/env node
/**
 * CallawayJP å•†å“è¯¦æƒ…æŠ“å–è„šæœ¬ v5.0 - å®Œå…¨ä¿®å¤ç‰ˆ
 * 
 * ä¿®å¤å†…å®¹:
 * - çœŸæ­£æå–é¡µé¢å•†å“èª¬æ˜å’Œå°ºç è¡¨å†…å®¹
 * - å›¾ç‰‡æŒ‰å˜ä½“åˆ†ç»„ä¸Šä¼ åˆ°images.variants
 * - è¾“å‡ºé£ä¹¦è„šæœ¬å®Œå…¨å…¼å®¹çš„JSONæ ¼å¼
 * - ä¸å†ä¾èµ–URLå‚æ•°æ‹¼å­—ç¬¦ä¸²ï¼Œä½¿ç”¨çœŸå®é¡µé¢æ•°æ®
 * 
 * ä½¿ç”¨æ–¹æ³•:
 * node CallawayJP/scripts/scrape_product_detail.js --url "https://www.callawaygolf.jp/..." --product-id "C25215200"
 */

const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

// å‘½ä»¤è¡Œå‚æ•°é…ç½®
const argv = yargs(hideBin(process.argv))
  .option('url', {
    alias: 'u',
    type: 'string',
    description: 'å•†å“è¯¦æƒ…é¡µ URL',
    demandOption: true
  })
  .option('product-id', {
    alias: 'p',
    type: 'string',
    description: 'äº§å“åŸºç¡€ IDï¼ˆå¦‚ C25215200ï¼‰',
    demandOption: true
  })
  .option('output-dir', {
    type: 'string',
    description: 'ç»“æœè¾“å‡ºç›®å½•',
    default: './CallawayJP/results/'
  })
  .option('temp-dir', {
    type: 'string',
    description: 'ä¸´æ—¶æ–‡ä»¶ç›®å½•',
    default: './callaway_tmp'
  })
  .option('debug-script', {
    type: 'boolean',
    description: 'è°ƒè¯•æ¨¡å¼ï¼šä»…æå–149652é•¿åº¦çš„scriptå†…å®¹',
    default: false
  })
  .help()
  .argv;

// é…ç½®å¸¸é‡
const OUTPUT_DIR = path.resolve(argv.outputDir);
const USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

// æµè§ˆå™¨é…ç½®
const BROWSER_OPTIONS = {
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-blink-features=AutomationControlled',
    '--disable-features=VizDisplayCompositor'
  ]
};

const CONTEXT_OPTIONS = {
  userAgent: USER_AGENT,
  locale: 'ja-JP',
  timezone: 'Asia/Tokyo',
  viewport: { width: 1920, height: 1080 },
  extraHTTPHeaders: {
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'ja-JP,ja;q=0.8,en-US;q=0.5,en;q=0.3',
    'Accept-Encoding': 'gzip, deflate, br',
    'DNT': '1',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    'Sec-Fetch-Dest': 'document',
    'Sec-Fetch-Mode': 'navigate',
    'Sec-Fetch-Site': 'none',
    'Cache-Control': 'max-age=0'
  }
};

// åŠ¨æ€æŠ“å–å…œåº•
const DEFAULT_COLOR_FALLBACK = [{ code: 'DEFAULT', name: 'DEFAULT' }];
const DEFAULT_SIZE_FALLBACK = ['FREE'];

// é¢œè‰²æ˜ å°„ï¼ˆä¿ç•™ç”¨äºè§£æç°æœ‰æ•°æ®ï¼‰
const COLOR_MAP = {
  '1031': { cn: 'è—è“è‰²' },
  '1030': { cn: 'æ·±è—è“' },
  '0100': { cn: 'ç™½è‰²' },
  '0010': { cn: 'é»‘è‰²' },
  '0200': { cn: 'çº¢è‰²' },
  '0300': { cn: 'è“è‰²' },
  '0400': { cn: 'ç°è‰²' },
  '0500': { cn: 'ç»¿è‰²' },
  '0600': { cn: 'ç²‰è‰²' },
  '0700': { cn: 'é»„è‰²' },
  '0800': { cn: 'æ©™è‰²' },
  '0900': { cn: 'ç´«è‰²' },
  '1000': { cn: 'æ£•è‰²' }
};

/**
 * ä»é¢œè‰²æ¡ç›®ä¸­æå–å±•ç¤ºåç§°
 */
function extractColorName(colorEntry) {
  if (!colorEntry) return '';
  if (typeof colorEntry === 'string') return colorEntry;
  return (
    colorEntry.name ||
    colorEntry.displayName ||
    colorEntry.displayValue ||
    colorEntry.label ||
    colorEntry.code ||
    ''
  );
}

/**
 * ä»é¢œè‰²æ¡ç›®ä¸­æå–é¢œè‰²ç¼–ç 
 */
function extractColorCode(colorEntry) {
  if (!colorEntry) return '';
  if (typeof colorEntry === 'string') return colorEntry;
  return (
    colorEntry.code ||
    colorEntry.id ||
    colorEntry.value ||
    colorEntry.rawValue ||
    ''
  );
}

/**
 * æ ¹æ®é¢œè‰²ç¼–ç æŸ¥æ‰¾é¢œè‰²å¯¹è±¡
 */
function findColorByCode(colorList, code) {
  if (!Array.isArray(colorList) || !code) return null;
  return (
    colorList.find(color => {
      if (!color) return false;
      if (typeof color === 'string') {
        return color === code;
      }
      const candidate = color;
      return (
        candidate.code === code ||
        candidate.id === code ||
        candidate.value === code ||
        candidate.rawValue === code
      );
    }) || null
  );
}

// é¢œè‰²è¾“å‡ºå·¥å…·
const colors = {
  green: (text) => `\x1b[32m${text}\x1b[0m`,
  red: (text) => `\x1b[31m${text}\x1b[0m`,
  yellow: (text) => `\x1b[33m${text}\x1b[0m`,
  blue: (text) => `\x1b[34m${text}\x1b[0m`,
  gray: (text) => `\x1b[90m${text}\x1b[0m`,
  magenta: (text) => `\x1b[35m${text}\x1b[0m`
};

/**
 * ç¡®ä¿ç›®å½•å­˜åœ¨
 */
async function ensureDir(dirPath) {
  try {
    await fs.access(dirPath);
  } catch {
    await fs.mkdir(dirPath, { recursive: true });
  }
}

/**
 * é¡µé¢åˆå§‹åŒ–
 */
async function setupPage(context) {
  const page = await context.newPage();
  
  // å±è”½è‡ªåŠ¨åŒ–æ£€æµ‹
  await page.addInitScript(() => {
    Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
    delete window.cdc_adoQpoasnfa76pfcZLmcfl_Array;
    delete window.cdc_adoQpoasnfa76pfcZLmcfl_Promise;
    delete window.cdc_adoQpoasnfa76pfcZLmcfl_Symbol;
  });
  
  return page;
}

/**
 * ğŸŒŸ çœŸæ­£ä»é¡µé¢æ•°æ®æå–äº§å“ä¿¡æ¯ï¼ˆä¿®å¤ç‰ˆï¼‰
 */
async function extractRealProductData(page, productId) {
  try {
    console.log(colors.blue('ğŸ” æå–çœŸå®äº§å“æ•°æ®...'));
    
    const realData = await page.evaluate(({ productId, colorMap }) => {
      const results = {
        product: {
          id: productId,
          title: '',
          description: '',
          brand: 'Callaway Golf',
          url: window.location.href
        },
        rawImages: [],
        descriptionText: '',
        sizeChartData: null,
        colors: [],
        sizes: [],
        dataSources: []
      };

      // =============================================
      // 1. ğŸŒŸ GLM-4.6 é‡å†™ï¼šè§£æ __next_f è„šæœ¬ä¸­çš„ productDetail
      // =============================================
      console.log('ğŸ” GLM-4.6: å¼€å§‹è§£æ __next_f è„šæœ¬ä¸­çš„äº§å“æ•°æ®...');
      
      // GLM-4.6: åˆå§‹åŒ–æ‰€æœ‰å˜é‡ï¼ˆé˜²æ­¢æœªå®šä¹‰é”™è¯¯ï¼‰
      let structuredData = null;
      let productDetail = null;
      let imagesByColor = {};
      let extractedColors = [];
      let extractedSizes = [];
      let sizeChart = null;
      let variantAttributes = null;
      
      try {
        // è§£æ __next_f è„šæœ¬å†…å®¹
        const scripts = document.querySelectorAll('script:not([src])');
        let foundProductDetail = false;
        
        console.log(`ğŸ” æ‰«æ ${scripts.length} ä¸ªå†…è”è„šæœ¬...`);
        
        for (let i = 0; i < scripts.length; i++) {
          const script = scripts[i];
          const content = script.textContent || script.innerHTML;
          
          // æŸ¥æ‰¾åŒ…å« productDetail çš„è„šæœ¬
          if (content.includes('__next_f.push') && content.includes('productDetail')) {
            console.log(`ğŸ“œ æ‰¾åˆ°åŒ…å«productDetailçš„è„šæœ¬ ${i+1}, é•¿åº¦: ${content.length}`);
            
            try {
              // æå– __next_f.push å‚æ•°ä¸­çš„ JSON æ•°æ®
              const pushMatches = content.match(/self\.__next_f\.push\(\[.*?\]\)/g);
              if (pushMatches) {
                console.log(`ğŸ” æ‰¾åˆ° ${pushMatches.length} ä¸ª __next_f.push è°ƒç”¨`);
                
                for (let j = 0; j < pushMatches.length; j++) {
                  const match = pushMatches[j];
                  
                  // æå–æ–¹æ‹¬å·å†…çš„å†…å®¹
                  const arrayMatch = match.match(/\[(.*?)\]$/);
                  if (arrayMatch) {
                    try {
                      const arrayContent = '[' + arrayMatch[1] + ']';
                      const parsedArray = JSON.parse(arrayContent);
                      
                      if (parsedArray.length >= 2) {
                        const dataString = parsedArray[1];
                        
                        // æ£€æŸ¥æ˜¯å¦åŒ…å« productDetail ç›¸å…³æ•°æ®
                        if (typeof dataString === 'string' && 
                            (dataString.includes('"productDetail"') || 
                             dataString.includes('"imageGroups"') ||
                             dataString.includes('"variationAttributes"') ||
                             dataString.includes('"sizeChart"'))) {
                          
                          console.log(`âœ“ åœ¨ push[${j}] ä¸­æ‰¾åˆ°äº§å“æ•°æ®`);
                          
                          // å°è¯•è§£æä¸º JSON
                          try {
                            // å¤„ç†å¯èƒ½çš„è½¬ä¹‰å­—ç¬¦
                            let cleanData = dataString;
                            if (cleanData.startsWith('"') && cleanData.endsWith('"')) {
                              cleanData = JSON.parse(cleanData);
                            }
                            
                            const jsonData = JSON.parse(cleanData);
                            
                            // æŸ¥æ‰¾ productDetail
                            if (jsonData.productDetail) {
                              productDetail = jsonData.productDetail;
                              foundProductDetail = true;
                              console.log('âœ“ ç›´æ¥æ‰¾åˆ° productDetail');
                              results.dataSources.push('__next_f.productDetail');
                              break;
                            }
                            
                            // é€’å½’æŸ¥æ‰¾ productDetail
                            function findProductDetail(obj, path = '') {
                              if (!obj || typeof obj !== 'object') return null;
                              
                              if (obj.productDetail) {
                                console.log(`âœ“ åœ¨ ${path} ä¸­æ‰¾åˆ° productDetail`);
                                return obj.productDetail;
                              }
                              
                              for (const [key, value] of Object.entries(obj)) {
                                if (typeof value === 'object' && value !== null) {
                                  const result = findProductDetail(value, path + '.' + key);
                                  if (result) return result;
                                }
                              }
                              return null;
                            }
                            
                            const foundDetail = findProductDetail(jsonData);
                            if (foundDetail) {
                              productDetail = foundDetail;
                              foundProductDetail = true;
                              results.dataSources.push('__next_f.nested.productDetail');
                              break;
                            }
                            
                          } catch (parseError) {
                            // ç»§ç»­æŸ¥æ‰¾ä¸‹ä¸€ä¸ª
                          }
                        }
                      }
                    } catch (e) {
                      // ç»§ç»­æŸ¥æ‰¾ä¸‹ä¸€ä¸ª
                    }
                  }
                }
              }
            } catch (e) {
              console.log(`âš ï¸ è§£æè„šæœ¬ ${i+1} å¤±è´¥:`, e.message);
            }
            
            if (foundProductDetail) break;
          }
        }
        
        if (productDetail) {
          console.log('ğŸ“‹ productDetail å­—æ®µ:', Object.keys(productDetail));
          
          // â­ æå– imageGroupsï¼ˆæ ¸å¿ƒéœ€æ±‚ï¼‰
          if (productDetail.imageGroups && Array.isArray(productDetail.imageGroups)) {
            console.log(`ğŸ–¼ï¸  æ‰¾åˆ° imageGroupsï¼Œå…± ${productDetail.imageGroups.length} ç»„`);
            
            productDetail.imageGroups.forEach((group, groupIndex) => {
              console.log(`\nğŸ“‚ å¤„ç†å›¾ç‰‡ç»„ ${groupIndex + 1}:`);
              console.log('   ç»„å­—æ®µ:', Object.keys(group));
              
              // æå–é¢œè‰²ä¿¡æ¯
              const colorCode = group.variationValue || group.colorCode || group.id || `color_${groupIndex}`;
              console.log(`   é¢œè‰²ä»£ç : ${colorCode}`);
              
              if (group.images && Array.isArray(group.images)) {
                console.log(`   å›¾ç‰‡æ€»æ•°: ${group.images.length}`);
                
                // ç­›é€‰ä¸»å›¾ï¼ˆæ’é™¤è¯´æ˜å›¾å’Œiconï¼‰
                const mainImages = [];
                  
                group.images.forEach((img, imgIndex) => {
                  if (img.url) {
                    // æ’é™¤è¯´æ˜å›¾å’Œiconï¼ˆæ ¹æ®URLç‰¹å¾ï¼‰
                    const isMainImage = !img.url.includes('icon') && 
                                       !img.url.includes('explanation') && 
                                       !img.url.includes('guide') &&
                                       !img.url.includes('size');
                    
                    if (isMainImage) {
                      // ä¼˜å…ˆä½¿ç”¨1080å®½åº¦ï¼Œå¦‚æœæ²¡æœ‰åˆ™è½¬æ¢å…¶ä»–å°ºå¯¸
                      let finalUrl = img.url;
                      if (img.url.includes('w=3000')) {
                        finalUrl = img.url.replace('w=3000', 'w=1080');
                      } else if (!img.url.includes('w=1080')) {
                        // å¦‚æœæ²¡æœ‰æ˜ç¡®çš„å®½åº¦å‚æ•°ï¼Œå°è¯•æ·»åŠ 
                        if (img.url.includes('&w=')) {
                          finalUrl = img.url.replace(/&w=\d+/, '&w=1080');
                        } else {
                          finalUrl = img.url + (img.url.includes('?') ? '&' : '?') + 'w=1080';
                        }
                      }
                      
                      mainImages.push({
                        originalUrl: finalUrl,
                        ossUrl: finalUrl,
                        alt: img.alt || '',
                        type: 'product_1080',
                        index: imgIndex,
                        colorCode: colorCode,
                        colorName: COLOR_MAP[colorCode] || colorCode,
                        size: '1080x1080'
                      });
                    }
                  }
                });
                
                if (mainImages.length > 0) {
                  imagesByColor[colorCode] = mainImages;
                  console.log(`   ç­›é€‰åä¸»å›¾: ${mainImages.length} å¼ `);
                }
              }
            });
          } else {
            console.log('âš ï¸ æœªæ‰¾åˆ° imageGroups');
          }
          
          // â­ æå–å˜ä½“å±æ€§ï¼ˆé¢œè‰²å’Œå°ºç ï¼‰
          if (productDetail.variationAttributes && Array.isArray(productDetail.variationAttributes)) {
            console.log('ğŸ¨ è§£æ variationAttributes...');
            
            productDetail.variationAttributes.forEach(attr => {
              const attrId = (attr.id || '').toLowerCase();
              const attrName = (attr.name || '').toLowerCase();
              
              console.log(`   å±æ€§: ${attr.id} (${attr.name})`);
              
              // è¯†åˆ«é¢œè‰²å±æ€§
              if (attrId.includes('color') || attrName.includes('color') || attrName.includes('ã‚«ãƒ©ãƒ¼')) {
                console.log('     â†’ é¢œè‰²å±æ€§');
                if (attr.values && Array.isArray(attr.values)) {
                  attr.values.forEach(val => {
                    const colorCode = val.value || val.id;
                    const colorName = val.displayValue || val.name || COLOR_MAP[colorCode] || colorCode;
                    if (colorCode) {
                      extractedColors.push({ code: colorCode, name: colorName });
                      console.log(`       + ${colorCode}: ${colorName}`);
                    }
                  });
                }
              }
              
              // è¯†åˆ«å°ºç å±æ€§
              if (attrId.includes('size') || attrName.includes('size') || attrName.includes('ã‚µã‚¤ã‚º')) {
                console.log('     â†’ å°ºç å±æ€§');
                if (attr.values && Array.isArray(attr.values)) {
                  attr.values.forEach(val => {
                    const sizeName = val.displayValue || val.value || val.name || val.id;
                    if (sizeName) {
                      extractedSizes.push(sizeName);
                      console.log(`       + ${sizeName}`);
                    }
                  });
                }
              }
            });
          }
          
          // â­ æå–å°ºç è¡¨
          const sizeChartFields = ['sizeChart', 'sizeChartHtml', 'specifications', 'spec', 'measurementChart', 'sizingChart'];
          for (const field of sizeChartFields) {
            if (productDetail[field]) {
              console.log(`ğŸ“ æ‰¾åˆ°å°ºç è¡¨å­—æ®µ: ${field}`);
              sizeChart = productDetail[field];
              break;
            }
          }
        } else {
          console.log('âš ï¸ æœªæ‰¾åˆ° productDetailï¼Œå°†ä½¿ç”¨ç°æœ‰DOMè§£æç»“æœ');
        }
      } catch (e) {
        console.log('âš ï¸ __next_f è„šæœ¬è§£æå¤±è´¥:', e.message);
      }
      
      // å»é‡å¤„ç†
      extractedColors = extractedColors.filter((color, index, self) => 
        index === self.findIndex(c => c.code === color.code)
      );
      extractedSizes = [...new Set(extractedSizes)];
      
      console.log('\nğŸ“Š __next_f è§£æç»“æœ:');
      console.log(`   é¢œè‰²: ${extractedColors.length} ç§`, extractedColors.map(c => `${c.code}(${c.name})`));
      console.log(`   å°ºç : ${extractedSizes.length} ç§`, extractedSizes);
      console.log(`   å›¾ç‰‡ç»„: ${Object.keys(imagesByColor).length} ç»„`);
      Object.entries(imagesByColor).forEach(([colorCode, images]) => {
        console.log(`     ${colorCode}: ${images.length} å¼ å›¾ç‰‡`);
      });
      
      // å»é‡å¤„ç†
      extractedColors = extractedColors.filter((color, index, self) => 
        index === self.findIndex(c => c.code === color.code)
      );
      extractedSizes = [...new Set(extractedSizes)];
      
      console.log('\nğŸ“Š NEXT_DATA è§£æç»“æœ:');
      console.log(`   é¢œè‰²: ${extractedColors.length} ç§`, extractedColors.map(c => `${c.code}(${c.name})`));
      console.log(`   å°ºç : ${extractedSizes.length} ç§`, extractedSizes);
      console.log(`   å›¾ç‰‡ç»„: ${Object.keys(imagesByColor).length} ç»„`);
      Object.entries(imagesByColor).forEach(([colorCode, images]) => {
        console.log(`     ${colorCode}: ${images.length} å¼ å›¾ç‰‡`);
      });
      
      // =============================================
      // 2. ğŸŒŸ GLM-4.6: ç®€åŒ–DOM fallbackï¼ˆä»…åœ¨NEXT_DATAå¤±è´¥æ—¶ä½¿ç”¨ï¼‰
      // =============================================
      // GLM-4.6: åªåœ¨NEXT_DATAè§£æå®Œå…¨å¤±è´¥æ—¶æ‰ä½¿ç”¨DOM fallback
      if (extractedColors.length === 0 && Object.keys(imagesByColor).length === 0) {
        console.log('âš ï¸ NEXT_DATAè§£æå¤±è´¥ï¼Œä½¿ç”¨DOM fallback...');
        
        // ç®€åŒ–çš„é¢œè‰²fallback
        if (extractedColors.length === 0) {
          console.log('ğŸ” DOM fallback - é¢œè‰² (GLM-4.6å¢å¼ºç‰ˆ)...');
          
          // æ›´å…¨é¢çš„é¢œè‰²é€‰æ‹©å™¨ï¼Œä¸“é—¨é’ˆå¯¹CallawayJPç½‘ç«™ç»“æ„
          const colorSelectors = [
            // æ ‡å‡†é¢œè‰²é€‰æ‹©å™¨
            'button[data-color]',
            'button[data-value]',
            '.color-selector button',
            '.product-color button',
            '.color-option',
            '.color-swatch',
            // CallawayJPç‰¹å®šé€‰æ‹©å™¨
            '.product-options button',
            '.variant-option',
            '.option-button',
            'button[class*="color"]',
            'button[class*="variant"]',
            // å›¾ç‰‡ä¸­çš„é¢œè‰²ä¿¡æ¯
            'img[alt*="è‰²"]',
            'img[alt*="ã‚«ãƒ©ãƒ¼"]',
            'img[alt*="ãƒã‚¤ãƒ“ãƒ¼"]',
            'img[alt*="ãƒ–ãƒ©ãƒƒã‚¯"]',
            'img[alt*="ãƒ›ãƒ¯ã‚¤ãƒˆ"]',
            'img[alt*="NAVY"]',
            'img[alt*="BLACK"]',
            'img[alt*="WHITE"]',
            // æ–‡æœ¬ä¸­çš„é¢œè‰²ä¿¡æ¯
            '.color-name',
            '.variant-name',
            'span[class*="color"]',
            'div[class*="color"]'
          ];
          
          const seenColors = new Set();
          
          // éå†æ‰€æœ‰é€‰æ‹©å™¨æŸ¥æ‰¾é¢œè‰²
          colorSelectors.forEach(selector => {
            try {
              const elements = document.querySelectorAll(selector);
              elements.forEach(el => {
                let colorText = '';
                
                // å¤šç§æ–¹å¼æå–é¢œè‰²ä¿¡æ¯
                if (el.dataset && el.dataset.color) {
                  colorText = el.dataset.color;
                } else if (el.dataset && el.dataset.value) {
                  colorText = el.dataset.value;
                } else if (el.alt) {
                  colorText = el.alt;
                } else if (el.textContent) {
                  colorText = el.textContent.trim();
                } else if (el.title) {
                  colorText = el.title;
                } else if (el.getAttribute('aria-label')) {
                  colorText = el.getAttribute('aria-label');
                }
                
                // è¿‡æ»¤å’Œæ¸…ç†é¢œè‰²å - æ›´ä¸¥æ ¼çš„è¿‡æ»¤
                if (colorText) {
                  const cleanColor = colorText.replace(/[^\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf\w\/]/g, '').trim();
                  
                  // ğŸŒŸ GLM-4.6ä¿®å¾©ï¼šæ”¾å¯¬é¡è‰²åµæ¸¬ï¼Œä¿ç•™æ‰€æœ‰æœ‰æ„ç¾©çš„é¡è‰²è³‡è¨Š
                  const isValidColor = cleanColor.length > 0 && cleanColor.length < 50 && 
                    !/^[\d\s]*$/.test(cleanColor) && // æ’é™¤ç´”æ•¸å­—å’Œç©ºç™½
                    !/^[.,:;!?]+$/.test(cleanColor); // æ’é™¤ç´”æ¨™é»ç¬¦è™Ÿ
                  if (isValidColor && cleanColor.length > 0 && cleanColor.length < 20) {
                    seenColors.add(cleanColor);
                  }
                }
              });
            } catch (e) {
              // å¿½ç•¥é€‰æ‹©å™¨é”™è¯¯ï¼Œç»§ç»­å…¶ä»–é€‰æ‹©å™¨
            }
          });
          
          // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°é¢œè‰²ï¼Œå°è¯•ä»é¡µé¢URLå’Œå†…å®¹ä¸­æ¨æ–­
          if (seenColors.size === 0) {
            console.log('ğŸ” å°è¯•ä»URLå’Œé¡µé¢å†…å®¹æ¨æ–­é¢œè‰²...');
            
            const pageContent = document.body.textContent.toLowerCase();
            const urlContent = window.location.href.toLowerCase();
            
            // CallawayJPå¸¸è§é¢œè‰²å…³é”®è¯
            const commonColors = [
              { keywords: ['navy', 'ãƒã‚¤ãƒ“ãƒ¼', '1031'], name: 'ãƒã‚¤ãƒ“ãƒ¼', code: '1031' },
              { keywords: ['black', 'ãƒ–ãƒ©ãƒƒã‚¯', '1040'], name: 'ãƒ–ãƒ©ãƒƒã‚¯', code: '1040' },
              { keywords: ['white', 'ãƒ›ãƒ¯ã‚¤ãƒˆ', '1000'], name: 'ãƒ›ãƒ¯ã‚¤ãƒˆ', code: '1000' },
              { keywords: ['red', 'ãƒ¬ãƒƒãƒ‰', '1600'], name: 'ãƒ¬ãƒƒãƒ‰', code: '1600' },
              { keywords: ['blue', 'ãƒ–ãƒ«ãƒ¼', '1030'], name: 'ãƒ–ãƒ«ãƒ¼', code: '1030' },
              { keywords: ['gray', 'grey', 'ã‚°ãƒ¬ãƒ¼', '1900'], name: 'ã‚°ãƒ¬ãƒ¼', code: '1900' }
            ];
            
            commonColors.forEach(color => {
              const found = color.keywords.some(keyword => 
                pageContent.includes(keyword) || urlContent.includes(keyword)
              );
              if (found) {
                seenColors.add(color.name);
              }
            });
          }
          
          extractedColors = Array.from(seenColors);
          console.log('âœ“ DOM fallbacké¢œè‰²ç»“æœ:', extractedColors);
          
          // ğŸŒŸ GLM-4.6ä¿®å¾©ï¼šä¸å†å¼·åˆ¶ä½¿ç”¨æ¨™æº–é¡è‰²ï¼Œè®“ normalizeColorEntries çµ±ä¸€è™•ç†
          if (extractedColors.length === 0) {
            console.log('ğŸ” DOM fallback æœªæ‰¾åˆ°é¡è‰²ï¼Œä¾è³´å¾ŒçºŒ normalizeColorEntries è™•ç†');
          }
        }
        
        // Fallback: å°ºç 
        if (extractedSizes.length === 0) {
          console.log('ğŸ” DOM fallback - å°ºç ...');
          
          const sizeSelectors = [
            'button[data-size]',
            '.size-selector button',
            '.product-size button',
            'option[value*="S"]',
            'option[value*="M"]',
            'option[value*="L"]'
          ];
          
          const seenSizes = new Set();
          sizeSelectors.forEach(selector => {
            const elements = document.querySelectorAll(selector);
            elements.forEach(el => {
              let sizeText = '';
              
              if (el.dataset && el.dataset.size) {
                sizeText = el.dataset.size;
              } else if (el.value) {
                sizeText = el.value;
              } else if (el.textContent) {
                sizeText = el.textContent.trim();
              }
              
              // æ¸…ç†å’ŒéªŒè¯å°ºç 
              if (sizeText) {
                const cleanSize = sizeText.replace(/[^A-Z0-9]/g, '').trim();
                if (cleanSize.match(/^(XS|S|M|L|XL|LL|XXL|[0-9]+)$/)) {
                  seenSizes.add(cleanSize);
                }
              }
            });
          });
          
          extractedSizes = Array.from(seenSizes);
          console.log('âœ“ DOM fallbackå°ºç ç»“æœ:', extractedSizes);
        }
      }
      
      // è®¾ç½®æœ€ç»ˆçš„é¢œè‰²å’Œå°ºç æ•°ç»„
      results.colors = extractedColors;
      results.sizes = extractedSizes;
      
      // =============================================
      // ğŸŒŸ è¾…åŠ©å‡½æ•°ï¼šHTMLå†…å®¹å¤„ç†ï¼Œä¿æŒæ®µè½ç»“æ„ (GLM-4.6é‡å†™)
      // =============================================
      function processHTMLToText(htmlContent) {
        if (!htmlContent || typeof htmlContent !== 'string') return '';
        
        try {
          // åˆ›å»ºä¸´æ—¶divæ¥è§£æHTML
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = htmlContent;
          
          // ç§»é™¤å›¾ç‰‡æ ‡ç­¾ä½†ä¿ç•™altæ–‡æœ¬ï¼ˆå¦‚æœæœ‰ç”¨ï¼‰
          const images = tempDiv.querySelectorAll('img');
          images.forEach(img => {
            const alt = img.getAttribute('alt');
            // åªä¿ç•™æœ‰æ„ä¹‰çš„altæ–‡æœ¬ï¼Œå¿½ç•¥è£…é¥°æ€§å›¾ç‰‡
            if (alt && alt.length > 2 && !alt.includes('icon') && !alt.includes('logo') && !alt.includes('badge')) {
              const textNode = document.createTextNode(`[${alt}]`);
              img.parentNode.replaceChild(textNode, img);
            } else {
              img.remove();
            }
          });
          
          // å¤„ç†å—çº§å…ƒç´ ï¼Œæ·»åŠ æ¢è¡Œ
          const blockElements = tempDiv.querySelectorAll('p, div, br, h1, h2, h3, h4, h5, h6, section, article, li');
          blockElements.forEach(el => {
            if (el.tagName === 'BR') {
              el.parentNode.replaceChild(document.createTextNode('\n'), el);
            } else if (el.tagName === 'LI') {
              // åˆ—è¡¨é¡¹å‰æ·»åŠ æ¢è¡Œ
              if (el.previousSibling) {
                el.parentNode.insertBefore(document.createTextNode('\n'), el);
              }
            } else {
              // åœ¨å—çº§å…ƒç´ åæ·»åŠ æ¢è¡Œ
              if (el.nextSibling) {
                el.parentNode.insertBefore(document.createTextNode('\n'), el.nextSibling);
              }
            }
          });
          
          // è·å–çº¯æ–‡æœ¬å†…å®¹
          let text = tempDiv.textContent || tempDiv.innerText || '';
          
          // æ¸…ç†æ–‡æœ¬ï¼šå‹ç¼©å¤šä½™ç©ºæ ¼å’Œæ¢è¡Œï¼Œä½†ä¿æŒæ®µè½ç»“æ„
          text = text
            .replace(/[ \t]+/g, ' ')  // å‹ç¼©ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦
            .replace(/\n{3,}/g, '\n\n')  // æœ€å¤šä¿ç•™ä¸¤ä¸ªè¿ç»­æ¢è¡Œ
            .replace(/^\s+|\s+$/g, '')  // å»é™¤é¦–å°¾ç©ºç™½
            .replace(/\n /g, '\n')  // å»é™¤æ¢è¡Œåçš„ç©ºæ ¼
            .replace(/ \n/g, '\n');  // å»é™¤æ¢è¡Œå‰çš„ç©ºæ ¼
          
          return text;
        } catch (e) {
          console.log('âš ï¸ HTMLå¤„ç†å¤±è´¥:', e.message);
          return htmlContent.replace(/<[^>]*>/g, '').trim();
        }
      }
      
      // =============================================
      // 4. ğŸŒŸ æå–å•†å“æè¿°ï¼ˆä¸“é—¨é’ˆå¯¹"å•†å“èª¬æ˜"tab - GLM-4.6é‡å†™ï¼‰
      // =============================================
      console.log('ğŸ” å¼€å§‹æå–å•†å“æè¿°...');
      
      // ç¬¬ä¸€æ­¥ï¼šå°è¯•ç»“æ„åŒ–æ•°æ®ï¼ˆå¢å¼ºè·¯å¾„ï¼‰
      let structuredDescription = '';
      if (productDetail) {
        const descSources = [
          { path: 'longDescription', value: productDetail.longDescription },
          { path: 'description', value: productDetail.description },
          { path: 'product.description', value: productDetail.product?.description },
          { path: 'product.longDescription', value: productDetail.product?.longDescription },
          { path: 'contentSections.description', value: productDetail.contentSections?.description },
          { path: 'contentSections.productDescription', value: productDetail.contentSections?.productDescription },
          { path: 'specifications.description', value: productDetail.specifications?.description },
          { path: 'details.description', value: productDetail.details?.description }
        ];
        
        for (const source of descSources) {
          if (source.value && typeof source.value === 'string' && source.value.trim().length > 100) {
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ—¥æ–‡å†…å®¹å’Œå…³é”®è¯
            const hasJapanese = /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(source.value);
            const hasProductKeywords = source.value.includes('ç´ æ') || source.value.includes('ä¼¸ç¸®') || source.value.includes('ã‚¹ãƒˆãƒ¬ãƒƒãƒ') || source.value.includes('MADE IN');
            
            if (hasJapanese && hasProductKeywords) {
              structuredDescription = processHTMLToText(source.value);
              console.log('âœ“ ä»ç»“æ„åŒ–æ•°æ®è·å–æè¿°:', source.path, 'é•¿åº¦:', structuredDescription.length);
              results.dataSources.push(`productDetail.${source.path}`);
              break;
            }
          }
        }
      }
      
      // ç¬¬äºŒæ­¥ï¼šDOM Fallback - ä¸“é—¨é’ˆå¯¹"å•†å“èª¬æ˜"tabå†…å®¹
      if (!structuredDescription) {
        console.log('ğŸ” DOM fallback - ç²¾ç¡®å®šä½"å•†å“èª¬æ˜"tabå†…å®¹...');
        
        // ğŸŒŸ æ–¹æ³•1: ç›´æ¥æŸ¥æ‰¾å•†å“æè¿°å®¹å™¨ï¼ˆæœ€ç²¾ç¡®ï¼‰
        const productDescriptionSelectors = [
          'section[data-testid*="description"]',
          '[data-testid="product-description"]',
          '[data-testid*="product-details"]',
          '[class*="product-description"]',
          '[class*="description-content"]',
          '.tab-content [data-testid*="description"]',
          '.tabpanel [data-testid*="description"]',
          '.tab-pane.active [class*="description"]'
        ];
        
        for (const selector of productDescriptionSelectors) {
          const container = document.querySelector(selector);
          if (container) {
            const htmlContent = container.innerHTML;
            const textContent = container.textContent || '';
            
            // éªŒè¯æ˜¯å¦ä¸ºå•†å“æè¿°å†…å®¹ï¼ˆåŒ…å«å…³é”®è¯ï¼‰
            const hasProductKeywords = textContent.includes('ç´ æ') || 
                                      textContent.includes('ä¼¸ç¸®') || 
                                      textContent.includes('ã‚¹ãƒˆãƒ¬ãƒƒãƒ') ||
                                      textContent.includes('MADE IN') ||
                                      textContent.includes('æ´—æ¿¯');
            
            const hasJapanese = /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(textContent);
            const isLongEnough = textContent.length > 200;
            
            if (hasProductKeywords && hasJapanese && isLongEnough) {
              structuredDescription = processHTMLToText(htmlContent);
              console.log('âœ“ é€šè¿‡ç²¾ç¡®é€‰æ‹©å™¨æ‰¾åˆ°å•†å“æè¿°:', selector, 'é•¿åº¦:', structuredDescription.length);
              results.dataSources.push(`DOM.${selector}`);
              break;
            }
          }
        }
        
        // ğŸŒŸ æ–¹æ³•2: å¯»æ‰¾åŒ…å«"å…¨æ–¹å‘ã«ä¼¸ç¸®æ€§"ç­‰ç‰¹å¾æ–‡æœ¬çš„å®¹å™¨
        if (!structuredDescription) {
          console.log('ğŸ” é€šè¿‡ç‰¹å¾æ–‡æœ¬æœç´¢å•†å“æè¿°å®¹å™¨...');
          
          const allContainers = document.querySelectorAll('section, div[class*="content"], div[class*="description"], .tab-content, .tabpanel, .tab-pane');
          
          for (const container of allContainers) {
            const text = container.textContent || '';
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æˆªå›¾ä¸­çš„ç‰¹å¾æ–‡æœ¬
            const hasCharacteristicText = text.includes('å…¨æ–¹å‘ã«ä¼¸ç¸®æ€§ãŒã‚ã‚Š') ||
                                         text.includes('ã‚„ã£ã±ã‚ŠåŠè¢–ã‚¹ã‚¿ã‚¤ãƒ«') ||
                                         text.includes('8WAYã‚¹ãƒˆãƒ¬ãƒƒãƒ') ||
                                         text.includes('ã‚¿ãƒ•ã‚¿ç´ æä½¿ç”¨') ||
                                         text.includes('ã‚¢ãƒãƒ©ãƒƒã‚¯é¢¨ã‚¢ã‚¦ã‚¿ãƒ¼');
            
            const hasRequiredContent = text.includes('ç´ æ:') && text.includes('MADE IN VIETNAM');
            
            if ((hasCharacteristicText || hasRequiredContent) && text.length > 300) {
              structuredDescription = processHTMLToText(container.innerHTML);
              console.log('âœ“ é€šè¿‡ç‰¹å¾æ–‡æœ¬æ‰¾åˆ°å•†å“æè¿°å®¹å™¨ï¼Œé•¿åº¦:', structuredDescription.length);
              results.dataSources.push('DOM.characteristicText');
              break;
            }
          }
        }
        
        // ğŸŒŸ æ–¹æ³•3: å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼Œæœç´¢åŒ…å«æè´¨ä¿¡æ¯çš„åŒºåŸŸ
        if (!structuredDescription) {
          console.log('ğŸ” æœç´¢åŒ…å«æè´¨ä¿¡æ¯çš„åŒºåŸŸ...');
          
          // æŸ¥æ‰¾åŒ…å«"ç´ æ:"å’Œ"MADE IN"çš„åŒºåŸŸ
          const allElements = document.querySelectorAll('*');
          let bestCandidate = null;
          let maxScore = 0;
          
          for (const el of allElements) {
            const text = el.textContent || '';
            
            if (text.length < 100 || text.length > 2000) continue; // é•¿åº¦è¿‡æ»¤
            
            let score = 0;
            if (text.includes('ç´ æ:')) score += 3;
            if (text.includes('MADE IN')) score += 3;
            if (text.includes('æ´—æ¿¯è¡¨ç¤º')) score += 2;
            if (text.includes('ã‚¹ãƒˆãƒ¬ãƒƒãƒ')) score += 2;
            if (text.includes('ãƒãƒªã‚¨ã‚¹ãƒ†ãƒ«')) score += 1;
            if (text.includes('ã‚„ã£ã±ã‚Š')) score += 2;  // ç‰¹å¾æ–‡æœ¬
            if (/[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(text)) score += 1;
            
            if (score > maxScore && score >= 5) {
              maxScore = score;
              bestCandidate = el;
            }
          }
          
          if (bestCandidate) {
            structuredDescription = processHTMLToText(bestCandidate.innerHTML);
            console.log('âœ“ é€šè¿‡æè´¨ä¿¡æ¯æœç´¢æ‰¾åˆ°å•†å“æè¿°ï¼Œåˆ†æ•°:', maxScore, 'é•¿åº¦:', structuredDescription.length);
            results.dataSources.push('DOM.materialInfo');
          }
        }
      }
      
      // è®¾ç½®æœ€ç»ˆç»“æœ
      results.descriptionText = structuredDescription;
      
      // å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°æè¿°ï¼Œæ‰“å°è­¦å‘Š
      if (!results.descriptionText || results.descriptionText.length < 100) {
        console.log('âš ï¸ è­¦å‘Šï¼šæœªèƒ½æå–åˆ°å®Œæ•´çš„å•†å“æè¿°å†…å®¹');
        results.descriptionText = results.descriptionText || '';
      } else {
        console.log('âœ“ å•†å“æè¿°æå–æˆåŠŸï¼Œæœ€ç»ˆé•¿åº¦:', results.descriptionText.length);
        console.log('âœ“ æè¿°å†…å®¹é¢„è§ˆ:', results.descriptionText.substring(0, 100) + '...');
      }
      
      // =============================================
      // ğŸŒŸ è¾…åŠ©å‡½æ•°ï¼šå°ºç è¡¨æ•°æ®å¤„ç†
      // =============================================
      function processSizeChartData(data, source) {
        if (!data) return null;
        
        try {
          // å¦‚æœæ˜¯HTMLå­—ç¬¦ä¸²ï¼Œè§£æä¸ºDOM
          if (typeof data === 'string' && data.includes('<')) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = data;
            const table = tempDiv.querySelector('table');
            if (table) {
              return extractTableData(table, source + ' (HTML)');
            }
            return null;
          }
          
          // å¦‚æœå·²ç»æ˜¯ headers/rows ç»“æ„
          if (data.headers && data.rows) {
            return {
              headers: data.headers.map(h => (h + '').trim()).filter(Boolean),
              rows: data.rows.map(row => 
                Array.isArray(row) ? row.map(cell => (cell + '').trim()).filter(Boolean) : []
              ).filter(row => row.length > 0)
            };
          }
          
          // å¦‚æœæ˜¯æ•°ç»„å¯¹è±¡æ ¼å¼ï¼ˆæ¯è¡Œä¸€ä¸ªå¯¹è±¡ï¼‰
          if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
            const headers = Object.keys(data[0]);
            const rows = data.map(row => headers.map(h => (row[h] + '').trim()));
            return {
              headers: headers.map(h => h.trim()).filter(Boolean),
              rows: rows.filter(row => row.some(cell => cell.length > 0))
            };
          }
          
          return null;
        } catch (e) {
          console.log('âš ï¸ å°ºç è¡¨æ•°æ®å¤„ç†å¤±è´¥:', e.message);
          return null;
        }
      }
      
      function extractTableData(table, source) {
        try {
          const headers = Array.from(table.querySelectorAll('thead th, tr:first-child th, tr:first-child td'))
            .map(th => th.textContent?.trim()).filter(Boolean);
          
          const rows = Array.from(table.querySelectorAll('tbody tr, tr:not(:first-child)'))
            .map(tr => Array.from(tr.querySelectorAll('td, th'))
              .map(cell => cell.textContent?.trim()).filter(Boolean))
            .filter(row => row.length > 0);
          
          if (headers.length > 0 && rows.length > 0) {
            console.log('âœ“ ä»', source, 'æå–å°ºç è¡¨ï¼š', headers.length, 'åˆ—,', rows.length, 'è¡Œ');
            return { headers, rows };
          }
          
          return null;
        } catch (e) {
          console.log('âš ï¸', source, 'è¡¨æ ¼è§£æå¤±è´¥:', e.message);
          return null;
        }
      }
      
      // =============================================
      // 6. ğŸŒŸ æå–å°ºç è¡¨ï¼ˆç»“æ„åŒ–æ•°æ®ä¼˜å…ˆ - é‡å†™ç‰ˆï¼‰
      // =============================================
      console.log('ğŸ” å¼€å§‹æå–å°ºç è¡¨...');
      
      // æŒ‰é¡ºåºå°è¯•ç»“æ„åŒ–æ•°æ®å­—æ®µ - å¢å¼ºè·¯å¾„æ£€æŸ¥
      const sizeChartSources = [
        { path: 'productDetail.sizeChart', getter: () => productDetail?.sizeChart },
        { path: 'productDetail.spec.sizeChart', getter: () => productDetail?.spec?.sizeChart },
        { path: 'productDetail.sizeChartHtml', getter: () => productDetail?.sizeChartHtml },
        { path: 'productDetail.specifications.sizeChart', getter: () => productDetail?.specifications?.sizeChart },
        { path: 'productDetail.product.sizeChart', getter: () => productDetail?.product?.sizeChart },
        { path: 'productDetail.contentSections.sizeChart', getter: () => productDetail?.contentSections?.sizeChart },
        { path: 'productDetail.variationGroups.sizeChart', getter: () => productDetail?.variationGroups?.sizeChart }
      ];
      
      for (const source of sizeChartSources) {
        const data = source.getter();
        if (data) {
          console.log('ğŸ” å°è¯•ä»', source.path, 'è·å–å°ºç è¡¨...');
          const processed = processSizeChartData(data, source.path);
          if (processed && processed.headers.length > 0 && processed.rows.length > 0) {
            results.sizeChartData = processed;
            results.dataSources.push(source.path);
            console.log('âœ“ ä»ç»“æ„åŒ–æ•°æ®è·å–å°ºç è¡¨æˆåŠŸ');
            break;
          }
        }
      }
      
      // ğŸŒŸ è¾…åŠ©å‡½æ•°ï¼šè§£ææ–‡æœ¬æ ¼å¼çš„å°ºç æ•°æ® (GLM-4.6é‡å†™ä¿®å¤ç‰ˆ)
      function parseTextSizeChart(textContent) {
        if (!textContent || typeof textContent !== 'string') return null;
        
        try {
          console.log('ğŸ” å¼€å§‹è§£ææ–‡æœ¬å°ºç è¡¨...');
          
          // æ–¹æ³•1ï¼šç›´æ¥ä½¿ç”¨å…¨å±€æ­£åˆ™åŒ¹é…æ‰€æœ‰å°ºç è¡Œï¼ˆä¼˜å…ˆï¼‰
          const globalPattern = /([SMLX]+L?)\s*\/\s*ãƒã‚¹ãƒˆ\s*([\d.]+)cm\s*\/\s*ç€ä¸ˆ\s*([\d.]+)cm\s*\/\s*è£„ä¸ˆ\s*([\d.]+)cm/g;
          const allMatches = [...textContent.matchAll(globalPattern)];
          
          if (allMatches.length > 0) {
            const rows = allMatches.map(match => [
              match[1].trim(),   // å°ºç 
              match[2].trim(),   // ãƒã‚¹ãƒˆ
              match[3].trim(),   // ç€ä¸ˆ
              match[4].trim()    // è£„ä¸ˆ
            ]);
            
            console.log('âœ“ é€šè¿‡å…¨å±€æ­£åˆ™è§£æå°ºç è¡¨ï¼š', rows.length, 'è¡Œæ•°æ®');
            console.log('âœ“ å°ºç æ•°æ®:', rows.map(row => row[0]).join(', '));
            
            return {
              headers: ['ã‚µã‚¤ã‚º', 'ãƒã‚¹ãƒˆ(cm)', 'ç€ä¸ˆ(cm)', 'è£„ä¸ˆ(cm)'],
              rows: rows
            };
          }
          
          // æ–¹æ³•2ï¼šå¯»æ‰¾åŒ…å«"å•†å“ã‚µã‚¤ã‚ºï¼ˆä»•ä¸ŠãŒã‚Šå¯¸æ³•ï¼‰"çš„åŒºåŸŸ
          const sizePattern = /å•†å“ã‚µã‚¤ã‚ºï¼ˆä»•ä¸ŠãŒã‚Šå¯¸æ³•ï¼‰([\s\S]*?)(?=\n\nâ€»|â€»|$)/;
          const sizeMatch = textContent.match(sizePattern);
          
          if (sizeMatch) {
            const sizeText = sizeMatch[1].trim();
            console.log('âœ“ æ‰¾åˆ°å°ºç åŒºåŸŸï¼Œå†…å®¹é•¿åº¦:', sizeText.length);
            
            // è§£ææ¯ä¸€è¡Œå°ºç æ•°æ®
            const lines = sizeText.split('\n').filter(line => line.trim().length > 0);
            const rows = [];
            
            console.log('âœ“ å°ºç åŒºåŸŸåˆ†è¡Œæ•°:', lines.length);
            
            for (const line of lines) {
              const trimmedLine = line.trim();
              console.log('âœ“ å¤„ç†è¡Œ:', trimmedLine.substring(0, 50) + '...');
              
              // è§£ææ ¼å¼: "S / ãƒã‚¹ãƒˆ 106cm / ç€ä¸ˆ 58cm / è£„ä¸ˆ 77.5cm"
              const lineMatch = trimmedLine.match(/([SMLX]+L?)\s*\/\s*ãƒã‚¹ãƒˆ\s*([\d.]+)cm\s*\/\s*ç€ä¸ˆ\s*([\d.]+)cm\s*\/\s*è£„ä¸ˆ\s*([\d.]+)cm/);
              
              if (lineMatch) {
                const rowData = [
                  lineMatch[1].trim(),   // å°ºç 
                  lineMatch[2].trim(),   // ãƒã‚¹ãƒˆ
                  lineMatch[3].trim(),   // ç€ä¸ˆ
                  lineMatch[4].trim()    // è£„ä¸ˆ
                ];
                rows.push(rowData);
                console.log('âœ“ è§£ææˆåŠŸ:', rowData.join(' | '));
              } else {
                console.log('âš ï¸ è¡Œä¸åŒ¹é…æ­£åˆ™:', trimmedLine);
              }
            }
            
            if (rows.length > 0) {
              console.log('âœ“ ä»åˆ†åŒºè§£æå°ºç è¡¨ï¼š', rows.length, 'è¡Œæ•°æ®');
              return {
                headers: ['ã‚µã‚¤ã‚º', 'ãƒã‚¹ãƒˆ(cm)', 'ç€ä¸ˆ(cm)', 'è£„ä¸ˆ(cm)'],
                rows: rows
              };
            }
          }
          
          console.log('âš ï¸ æœªèƒ½æ‰¾åˆ°æœ‰æ•ˆçš„å°ºç æ•°æ®');
          return null;
        } catch (e) {
          console.log('âš ï¸ æ–‡æœ¬å°ºç è¡¨è§£æå¤±è´¥:', e.message);
          return null;
        }
      }
      
      // DOM fallbackï¼ˆå¢å¼ºç‰ˆ - GLM-4.6é‡å†™ï¼‰
      if (!results.sizeChartData) {
        console.log('ğŸ” DOM fallback - å¯»æ‰¾å°ºç è¡¨...');
        
        // ğŸŒŸ æ–¹æ³•1: ä¼˜å…ˆå°è¯•ä»å·²æå–çš„å•†å“æè¿°ä¸­è§£æ
        if (results.descriptionText && results.descriptionText.includes('å•†å“ã‚µã‚¤ã‚º')) {
          console.log('ğŸ” ä»å•†å“æè¿°ä¸­è§£æå°ºç è¡¨...');
          const parsedSizeChart = parseTextSizeChart(results.descriptionText);
          if (parsedSizeChart) {
            results.sizeChartData = parsedSizeChart;
            results.dataSources.push('DOM.descriptionText');
            console.log('âœ“ ä»å•†å“æè¿°æ–‡æœ¬ä¸­è§£æå°ºç è¡¨æˆåŠŸ');
          }
        }
        
        // ğŸŒŸ æ–¹æ³•2: å¦‚æœæè¿°ä¸­æ²¡æœ‰ï¼Œåœ¨DOMä¸­æœç´¢å°ºç æ–‡æœ¬
        if (!results.sizeChartData) {
          console.log('ğŸ” åœ¨DOMä¸­æœç´¢å°ºç æ–‡æœ¬...');
          
          // æŸ¥æ‰¾åŒ…å«å°ºç ä¿¡æ¯çš„å…ƒç´ 
          const allElements = document.querySelectorAll('*');
          
          for (const element of allElements) {
            const elementText = element.textContent || '';
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«å°ºç è¡¨ç‰¹å¾
            if (elementText.includes('å•†å“ã‚µã‚¤ã‚º') && elementText.includes('ãƒã‚¹ãƒˆ') && elementText.includes('ç€ä¸ˆ')) {
              const parsedSizeChart = parseTextSizeChart(elementText);
              if (parsedSizeChart) {
                results.sizeChartData = parsedSizeChart;
                results.dataSources.push('DOM.sizeTextElement');
                console.log('âœ“ ä» DOM å…ƒç´ æ–‡æœ¬ä¸­è§£æå°ºç è¡¨æˆåŠŸ');
                break;
              }
            }
          }
        }
        
        // ğŸŒŸ æ–¹æ³•3: ç»§ç»­åŸæœ‰çš„HTMLè¡¨æ ¼æŸ¥æ‰¾é€»è¾‘ä½œä¸ºfallback
        if (!results.sizeChartData) {
          console.log('ğŸ” åœ¨DOMä¸­æœç´¢HTMLè¡¨æ ¼...');
          
          const sizeChartSelectors = [
            // ä¼˜å…ˆæŸ¥æ‰¾æ˜ç¡®çš„å°ºç åŒºåŸŸ
            '[data-testid*="size-chart"] table',
            '[id*="size-chart"] table',
            '[class*="size-chart"] table',
            // æŸ¥æ‰¾äº§å“è¯¦æƒ…tabä¸­çš„è¡¨æ ¼
            '[data-testid*="product-details"] table',
            '[id*="product-details"] table',
            '[class*="product-details"] table',
            // é€šç”¨è¡¨æ ¼é€‰æ‹©å™¨
            'section table',
            '.tab-content table',
            'table[class*="size"]',
            'table'
          ];
          
          for (const selector of sizeChartSelectors) {
            const tables = document.querySelectorAll(selector);
            
            for (const table of tables) {
              const tableText = table.textContent || '';
              
              // æ›´ç²¾ç¡®çš„å°ºç è¡¨è¯†åˆ«
              const hasSizeKeywords = tableText.includes('ã‚µã‚¤ã‚º') || tableText.includes('Size') || tableText.includes('size');
              const hasSizeValues = /[SML]{1,2}|XS|XL|LL|XXL/.test(tableText);
              const hasMeasurements = /cm|ã‚»ãƒ³ãƒ|èƒ¸å›²|ç€ä¸ˆ|è‚©å¹…|è£„ä¸ˆ|ãƒã‚¹ãƒˆ/.test(tableText);
              
              if (hasSizeKeywords && (hasSizeValues || hasMeasurements)) {
                console.log('âœ“ æ‰¾åˆ°ç–‘ä¼¼å°ºç è¡¨ï¼Œå†…å®¹é¢„è§ˆ:', tableText.substring(0, 100) + '...');
                
                const extracted = extractTableData(table, 'DOM.table');
                if (extracted) {
                  results.sizeChartData = extracted;
                  results.dataSources.push('DOM.htmlTable');
                  break;
                }
              }
            }
            
            if (results.sizeChartData) break;
          }
        }
      }
      
      // ç¡®ä¿æœ€ç»ˆè¾“å‡ºä¸æ˜¯null (ç”¨æˆ·è¦æ±‚ï¼šæ°¸è¿œä¸è¿”å›null)
      if (!results.sizeChartData) {
        console.log('âš ï¸ æœªæ‰¾åˆ°å°ºç è¡¨ï¼Œè®¾ç½®ç©ºç»“æ„');
        results.sizeChartData = { headers: [], rows: [] };
      } else {
        // éªŒè¯ç»“æ„å®Œæ•´æ€§
        if (!results.sizeChartData.headers) {
          results.sizeChartData.headers = [];
        }
        if (!results.sizeChartData.rows) {
          results.sizeChartData.rows = [];
        }
      }
      
      // =============================================
      // 7. ğŸŒŸ å›¾ç‰‡æå– - GLM-4.6é‡æ–°è®¾è®¡ï¼šå»¶è¿Ÿåˆ°æµè§ˆå™¨å¤–å¤„ç†
      // =============================================
      console.log('ğŸ” GLM-4.6é‡æ–°è®¾è®¡ï¼šåŸºç¡€æ•°æ®æå–å®Œæˆï¼Œå‡†å¤‡å›¾ç‰‡äº¤äº’æŠ“å–...');
      
      // æš‚æ—¶è¿”å›ç©ºæ•°ç»„ï¼Œå›¾ç‰‡å°†åœ¨æµè§ˆå™¨å¤–é€šè¿‡é¢œè‰²äº¤äº’æŠ“å–
      results.rawImages = [];
      results.imagesByColor = {}; // å°†é€šè¿‡ extractImagesByColorInteraction å¡«å……
      
      return results;
    }, { productId, colorMap: COLOR_MAP });
    
    console.log(colors.green(`âœ“ GLM-4.6é‡å†™ç‰ˆæ•°æ®æå–å®Œæˆ`));
    console.log(colors.gray(`  æè¿°é•¿åº¦: ${realData.descriptionText.length}`));
    const initialColorNames = Array.isArray(realData.colors)
      ? realData.colors.map(extractColorName).filter(Boolean)
      : [];
    console.log(colors.gray(`  é¢œè‰²æ•°ç»„: [${initialColorNames.join(', ')}] (${initialColorNames.length}ä¸ª)`));
    console.log(colors.gray(`  å°ºç æ•°ç»„: [${realData.sizes.join(', ')}] (${realData.sizes.length}ä¸ª)`));
    console.log(colors.gray(`  å°ºç è¡¨: ${realData.sizeChartData ? 'å·²æå–' : 'æœªæ‰¾åˆ°'}`));
    console.log(colors.gray(`  å›¾ç‰‡æ•°é‡: ${realData.rawImages.length} (åŸºç¡€æå–)`));
    console.log(colors.gray(`  æ•°æ®æº: ${realData.dataSources.join(', ')}`));
    
    // ğŸŒŸ GLM-4.6æ–°å¢ï¼šé€šè¿‡é¢œè‰²äº¤äº’æŠ“å–1080Ã—1080å•†å“å›¾
    if (realData.colors && realData.colors.length > 0) {
      console.log(colors.blue(`ğŸ¨ å¼€å§‹é¢œè‰²äº¤äº’å›¾ç‰‡æŠ“å– (${realData.colors.length} ä¸ªé¢œè‰²)...`));
      
      try {
        const imageData = await extractImagesByColorInteraction(page, productId, realData.colors);
        
        if (imageData.colorMetadata && imageData.colorMetadata.length > 0) {
          realData.colorMetadata = imageData.colorMetadata;
          // ğŸŒŸ GLM-4.6ä¿®å¾©ï¼šä¸è¦†è“‹ realData.colorsï¼Œä¿ç•™DOM fallbackçš„é¡è‰²ä¾›å¾ŒçºŒåˆä½µ
          const imageColors = imageData.colorMetadata.map(meta => ({
            code: meta.code,
            name: meta.name,
            displayName: meta.displayName,
            rawValue: meta.rawValue
          }));
          console.log(`ğŸ” GLM-4.6: ä¿ç•™DOM fallbacké¡è‰²ï¼Œåœ–ç‰‡é¡è‰²å–®ç¨è™•ç†`);
          // ä¸è¦†è“‹ realData.colorsï¼Œè®“å¾ŒçºŒåˆä½µé‚è¼¯è™•ç†
        }
        
        // å°†æŒ‰é¢œè‰²åˆ†ç»„çš„å›¾ç‰‡æ•°æ®åˆå¹¶åˆ°realDataä¸­
        realData.imagesByColor = imageData.imagesByColor;
        
        // å°†æ‰€æœ‰å›¾ç‰‡åˆå¹¶åˆ°rawImagesæ•°ç»„ä¸­ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
        realData.rawImages = imageData.allImages;
        
        console.log(colors.green(`âœ“ é¢œè‰²äº¤äº’å›¾ç‰‡æŠ“å–å®Œæˆ`));
        console.log(colors.gray(`  æŒ‰é¢œè‰²åˆ†ç»„: ${Object.keys(realData.imagesByColor).length} ä¸ªé¢œè‰²`));
        console.log(colors.gray(`  æ€»å›¾ç‰‡æ•°é‡: ${realData.rawImages.length} å¼ `));
        
        // æ‰“å°æ¯ä¸ªé¢œè‰²çš„å›¾ç‰‡æ•°é‡ç»Ÿè®¡
        Object.entries(realData.imagesByColor).forEach(([colorCode, images]) => {
          const colorInfo = findColorByCode(realData.colors, colorCode);
          const colorName = extractColorName(colorInfo) || colorCode;
          console.log(colors.gray(`    ${colorName}: ${images.length} å¼ `));
        });
        
      } catch (imageError) {
        console.error(colors.red(`âœ— å›¾ç‰‡æŠ“å–å¤±è´¥: ${imageError.message}`));
        console.log(colors.yellow(`  å›¾ç‰‡åŠŸèƒ½å¾…é‡æ„å®ç°...`));
        
        // ä¿æŒåŸæœ‰çš„ç©ºå›¾ç‰‡ç»“æ„
        realData.imagesByColor = {};
        realData.rawImages = [];
      }
    } else {
      console.log(colors.yellow(`âš ï¸ æœªæ‰¾åˆ°é¢œè‰²ä¿¡æ¯ï¼Œå›¾ç‰‡æŠ“å–å¾…å®ç°`));
      realData.imagesByColor = {};
      realData.rawImages = [];
    }
    
    // ğŸŒŸ GLM-4.6: æ•´åˆ NEXT_DATA è§£æç»“æœåˆ° realDataï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    console.log('ğŸ”§ æ£€æŸ¥ NEXT_DATA è§£æç»“æœ...');
    
    // æ£€æŸ¥å˜é‡æ˜¯å¦å­˜åœ¨ï¼ˆé˜²æ­¢æœªå®šä¹‰é”™è¯¯ï¼‰
    if (typeof extractedColors !== 'undefined' && extractedColors.length > 0) {
      realData.colors = extractedColors;
      console.log(`âœ“ ä½¿ç”¨ NEXT_DATA é¢œè‰²: ${extractedColors.length} ç§`);
    } else {
      console.log('âš ï¸ NEXT_DATA é¢œè‰²æ•°æ®ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å€¼');
    }
    
    if (typeof extractedSizes !== 'undefined' && extractedSizes.length > 0) {
      realData.sizes = extractedSizes;
      console.log(`âœ“ ä½¿ç”¨ NEXT_DATA å°ºç : ${extractedSizes.length} ç§`);
    } else {
      console.log('âš ï¸ NEXT_DATA å°ºç æ•°æ®ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å€¼');
    }
    
    if (typeof sizeChart !== 'undefined' && sizeChart) {
      realData.sizeChartData = sizeChart;
      console.log('âœ“ ä½¿ç”¨ NEXT_DATA å°ºç è¡¨');
    } else {
      console.log('âš ï¸ NEXT_DATA å°ºç è¡¨ä¸å¯ç”¨');
    }
    
    // ä½¿ç”¨ NEXT_DATA çš„å›¾ç‰‡æ•°æ®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    if (typeof imagesByColor !== 'undefined' && Object.keys(imagesByColor).length > 0) {
      realData.imagesByColor = imagesByColor;
      
      // æ„å»ºé¢œè‰²å…ƒæ•°æ®
      const colorMetadata = [];
      Object.keys(imagesByColor).forEach(colorCode => {
        const colorInfo = (typeof extractedColors !== 'undefined' && extractedColors.find) ?
                          extractedColors.find(c => c.code === colorCode) : null;
        const finalColorInfo = colorInfo || { code: colorCode, name: COLOR_MAP[colorCode] || 'DEFAULT' };
        colorMetadata.push({
          code: colorCode,
          name: finalColorInfo.name,
          displayName: finalColorInfo.name,
          rawValue: colorCode
        });
      });
      realData.colorMetadata = colorMetadata;
      
      // æ„å»º rawImages æ•°ç»„ï¼ˆå‘åå…¼å®¹ï¼‰
      const allImages = [];
      Object.values(imagesByColor).forEach(images => {
        allImages.push(...images);
      });
      realData.rawImages = allImages;
      
      console.log(`âœ“ ä½¿ç”¨ NEXT_DATA å›¾ç‰‡: ${Object.keys(imagesByColor).length} ä¸ªé¢œè‰²ï¼Œ${allImages.length} å¼ å›¾ç‰‡`);
    } else {
      console.log('âš ï¸ NEXT_DATA å›¾ç‰‡æ•°æ®ä¸å¯ç”¨ï¼Œä½¿ç”¨ç°æœ‰å›¾ç‰‡æŠ½å–ç»“æœ');
    }
    
    console.log('ğŸ† æ•°æ®æ•´åˆå®Œæˆ!');
    
    // ğŸŒŸ GLM-4.6ä¿®å¾© + validColorCodes éæ¿¾ï¼šä½¿ç”¨ variationAttributes ä½œç‚ºçœŸå¯¦ä¾†æºéæ¿¾æ–‡å­—å™ªéŸ³
    // è™•ç† extractedColors å¯èƒ½æ˜¯å­—ç¬¦ä¸²æ•¸çµ„çš„æƒ…æ³ï¼Œä½¿ç”¨ realData.colors è€Œä¸æ˜¯å±€éƒ¨è®Šé‡
    console.log(`ğŸ” GLM-4.6èª¿è©¦: realData.colors å…§å®¹:`, realData.colors || []);
    console.log(`ğŸ” GLM-4.6èª¿è©¦: realData.colorMetadata å…§å®¹:`, realData.colorMetadata || []);
    
    const normalizedExtractedColors = (Array.isArray(realData.colors)) 
      ? realData.colors.map(color => typeof color === 'string' ? { code: color, name: color } : color)
      : [];
    
    console.log(`ğŸ” GLM-4.6èª¿è©¦: normalizedExtractedColors:`, normalizedExtractedColors);
    
    // ğŸŒŸ æ™ºèƒ½ validColorCodes æ˜ å°„ï¼šå„ªå…ˆ variationAttributesï¼Œå‚™ç”¨æ¨¡å¼è­˜åˆ¥åˆæ³•é¡è‰²
    const validColorCodes = new Set();
    const validColorMapping = new Map();
    
    // å¦‚æœå¾ variationAttributes ç²å¾—é¡è‰²ï¼Œä½¿ç”¨é€™äº›ä½œç‚ºçœŸå¯¦ä¾†æº
    if (normalizedExtractedColors.length > 0 && normalizedExtractedColors.every(c => 
      !c.code.includes('ã‚¯ãƒ©ãƒ–') && !c.code.includes('chevron') && !c.code.includes('ã‚«ãƒ¼ãƒˆ')
    )) {
      // æœ‰æ•ˆçš„ variationAttributes æ•¸æ“š
      normalizedExtractedColors.forEach(color => {
        if (color.code && color.name) {
          validColorCodes.add(color.code);
          validColorMapping.set(color.code, color);
          console.log(`âœ“ åˆæ³•é¡è‰² (variationAttributes): ${color.code} (${color.name})`);
        }
      });
    } else {
      // å‚™ç”¨æ¨¡å¼ï¼šæ™ºèƒ½è­˜åˆ¥çœŸå¯¦é¡è‰²ï¼Œéæ¿¾å°è¦½æ–‡å­—
      console.log(`âš ï¸ variationAttributes ä¸å¯ç”¨ï¼Œä½¿ç”¨æ™ºèƒ½é¡è‰²è­˜åˆ¥`);
      const intelligentColorFilter = (colorText) => {
        // é¡è‰²æ¨¡å¼åŒ¹é…
        const colorPatterns = [
          /^[A-Z]+\/[A-Z]+$/,           // WHITE/NAVY, WHITE/BLACK æ ¼å¼
          /^[A-Z]+$/,                  // BLACK, WHITE, NAVY ç­‰å–®ä¸€é¡è‰²
          /^\d{4}$/,                   // 4ä½æ•¸å­—ä»£ç¢¼å¦‚ 1010, 1030
          /^(red|blue|green|yellow|black|white|navy|gray|grey|pink|purple|orange|brown)$/i  // æ¨™æº–é¡è‰²å
        ];
        
        // æ’é™¤æ¨¡å¼
        const excludePatterns = [
          /chevron/i, /ã‚¯ãƒ©ãƒ–/, /ã‚¢ãƒ‘ãƒ¬ãƒ«/, /ãƒœãƒ¼ãƒ«/, /ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼/, /ã‚¦ã‚£ãƒ¡ãƒ³ã‚º/, 
          /èªå®šä¸­å¤/, /ãƒ–ãƒ©ãƒ³ãƒ‰/, /ã‚¹ãƒˆã‚¢/, /barssolid/, /ã‚«ãƒ¼ãƒˆ/, /ãŠæ°—ã«å…¥ã‚Š/,
          /æ³¨æ–‡/, /å•†å“èª¬æ˜/, /ã‚µã‚¤ã‚º/, /ãƒ¬ãƒ“ãƒ¥ãƒ¼/, /é€æ–™/, /ãƒ¡ãƒ³ãƒãƒ¼/, /ä¸‹å–ã‚Š/, /è¿”å“/, /åˆ°ç€/
        ];
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºåˆæ³•é¡è‰²
        const isValidColor = colorPatterns.some(pattern => pattern.test(colorText));
        const isExcluded = excludePatterns.some(pattern => pattern.test(colorText));
        
        return isValidColor && !isExcluded;
      };
      
      normalizedExtractedColors.forEach(color => {
        if (color.code && intelligentColorFilter(color.code)) {
          validColorCodes.add(color.code);
          validColorMapping.set(color.code, color);
          console.log(`âœ“ åˆæ³•é¡è‰² (æ™ºèƒ½è­˜åˆ¥): ${color.code} (${color.name})`);
        } else {
          console.log(`âŒ éæ¿¾æ‰å°è¦½æ–‡å­—: ${color.code} (${color.name})`);
        }
      });
    }
    
    console.log(`ğŸ”§ å»ºç«‹ validColorCodes: ${validColorCodes.size} å€‹åˆæ³•é¡è‰²`, [...validColorCodes]);
    
    // ğŸŒŸ éæ¿¾ colorMetadataï¼šåªä¿ç•™åœ¨ validColorCodes ä¸­çš„é¡è‰²
    const filteredColorMetadata = (realData.colorMetadata || []).filter(color => {
      const isValid = validColorCodes.has(color.code);
      if (!isValid) {
        console.log(`âŒ éæ¿¾æ‰éé¡è‰²æ–‡å­—: ${color.code} (${color.name})`);
      }
      return isValid;
    });
    
    console.log(`ğŸ”§ éæ¿¾å¾Œ colorMetadata: ${filteredColorMetadata.length} å€‹`, filteredColorMetadata.map(c => c.code));
    
    // ğŸŒŸ åªä½¿ç”¨å·²éæ¿¾çš„åˆæ³•é¡è‰²é€²è¡Œåˆä½µ
    const validExtractedColors = Array.from(validColorMapping.values());
    console.log(`ğŸ”§ ä½¿ç”¨å·²éæ¿¾çš„åˆæ³•é¡è‰²: ${validExtractedColors.length} å€‹`, validExtractedColors.map(c => c.code));
    
    const mergedColors = normalizeColorEntries([
      ...validExtractedColors,
      ...filteredColorMetadata
    ]);
    
    console.log(`ğŸ” GLM-4.6èª¿è©¦: mergedColors æœ€çµ‚çµæœ (å·²éæ¿¾):`, mergedColors);

    // ç‚ºæ‰€æœ‰é¡è‰²è£œé½Š imagesByColor ç©ºé™£åˆ—
    mergedColors.forEach(color => {
      if (!realData.imagesByColor[color.code]) {
        realData.imagesByColor[color.code] = [];
      }
    });

    realData.colorMetadata = mergedColors;
    realData.colors = mergedColors;
    
    console.log(`ğŸ”§ GLM-4.6é¡è‰²åˆä½µå®Œæˆ: ${mergedColors.length} å€‹é¡è‰² (${mergedColors.map(c => c.code).join(', ')})`);
    
    realData.colors = normalizeColorEntries(realData.colors);
    realData.sizes = normalizeSizeEntries(realData.sizes);
    
    return realData;
  } catch (error) {
    console.error(colors.red(`âœ— çœŸå®æ•°æ®æå–å¤±è´¥: ${error.message}`));
    return {
      product: { id: productId, title: '', description: '', brand: 'Callaway Golf', url: '' },
      rawImages: [],
      descriptionText: '',
      sizeChartData: null,
      colors: [],
      sizes: [],
      dataSources: []
    };
  }
}

/**
 * ğŸŒŸ åˆå¹¶çœŸå®æ•°æ®å’Œæ ‡å‡†å˜ä½“ï¼ˆä¿®å¤ç‰ˆï¼‰
 */
<<<<<<< HEAD
function normalizeColorEntries(rawColors) {
  if (!Array.isArray(rawColors) || rawColors.length === 0) {
    return [...DEFAULT_COLOR_FALLBACK];
  }

  const normalized = rawColors
    .map((entry, index) => {
      if (!entry) return null;

      if (typeof entry === 'string') {
        const code = entry.trim();
        return {
          code: code || `COLOR_${index}`,
          name: COLOR_MAP[code] || code || `COLOR_${index}`,
          rawValue: entry
        };
      }

      const code = entry.code || entry.id || entry.value || entry.rawValue || `COLOR_${index}`;
      const name =
        entry.name ||
        entry.displayName ||
        entry.displayValue ||
        COLOR_MAP[code] ||
        code;

      return {
        code: String(code).trim() || `COLOR_${index}`,
        name: String(name).trim() || `COLOR_${index}`,
        rawValue: entry
      };
    })
    .filter(Boolean);

  const seen = new Set();
  const unique = normalized.filter(color => {
    const key = color.code || color.name;
    if (!key) return false;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  return unique.length > 0 ? unique : [...DEFAULT_COLOR_FALLBACK];
}

function normalizeSizeEntries(rawSizes) {
  if (!Array.isArray(rawSizes) || rawSizes.length === 0) {
    return [...DEFAULT_SIZE_FALLBACK];
  }

  const normalized = rawSizes
    .map((entry, index) => {
      if (!entry) return null;

      if (typeof entry === 'string') {
        return entry.trim();
      }

      return (
        entry.displayValue ||
        entry.value ||
        entry.name ||
        entry.id ||
        `SIZE_${index}`
      );
    })
    .filter(Boolean)
    .map(value => value.trim())
    .filter(Boolean);

  const seen = new Set();
  const unique = normalized.filter(size => {
    if (seen.has(size)) return false;
    seen.add(size);
    return true;
  });

  return unique.length > 0 ? unique : [...DEFAULT_SIZE_FALLBACK];
}

function createDynamicVariants(productId, rawColors, rawSizes) {
  try {
    const normalizedColors = normalizeColorEntries(rawColors);
    const normalizedSizes = normalizeSizeEntries(rawSizes);

    console.log(colors.blue('ğŸ”„ åŠ¨æ€ç”Ÿæˆå˜ä½“ç»„åˆ...'));
    console.log(colors.gray(`  æ£€æµ‹åˆ°é¢œè‰²: ${normalizedColors.length} ä¸ª`));
    console.log(colors.gray(`  æ£€æµ‹åˆ°å°ºç : ${normalizedSizes.length} ä¸ª`));

    const variants = [];

    normalizedColors.forEach(color => {
      normalizedSizes.forEach(sizeValue => {
        const sizeCode = sizeValue || 'DEFAULT';
        const variantId = `${productId}_${color.code}_${sizeCode}`;

        variants.push({
          variantId,
          colorName: color.name,
          colorCode: color.code,
          sizeName: sizeValue,
          sizeCode: sizeCode,
          availability: 'unknown',
          sku: variantId,
          priceJPY: null
        });
      });
    });

    console.log(colors.green(`âœ“ å˜ä½“ç”Ÿæˆå®Œæˆ: ${variants.length} ä¸ªç»„åˆ`));

    return {
      colors: normalizedColors,
      sizes: normalizedSizes,
      variants
    };
  } catch (error) {
    console.error(colors.red(`âœ— åŠ¨æ€å˜ä½“ç”Ÿæˆå¤±è´¥: ${error.message}`));
    return {
      colors: [...DEFAULT_COLOR_FALLBACK],
      sizes: [...DEFAULT_SIZE_FALLBACK],
      variants: []
    };
  }
}

/**
 * ğŸŒŸ åˆå¹¶çœŸå®æ•°æ®å’Œæ ‡å‡†å˜ä½“ï¼ˆä¿®å¤ç‰ˆï¼‰
 */
function buildFinalProductData(realData, productId) {
  console.log(colors.blue('ğŸ”„ æ„å»ºæœ€ç»ˆäº§å“æ•°æ®...'));

  // ğŸŒŸ ä½¿ç”¨è¿‡æ»¤åçš„é¢œè‰²æ•°æ®æ„å»ºå˜ä½“ï¼Œé¿å…å¯¼èˆªæ–‡å­—æ±¡æŸ“
  const filteredColors = Array.isArray(realData.colorMetadata) && realData.colorMetadata.length > 0 
    ? realData.colorMetadata 
    : Array.isArray(realData.colors) ? realData.colors : [];
=======
function buildFinalProductData(realData, productId) {
  console.log(colors.blue('ğŸ”„ æ„å»ºæœ€ç»ˆäº§å“æ•°æ®...'));

  // æå–é¢œè‰²æ•°æ®
  const colorDetails = Array.isArray(realData.colors) ? realData.colors : [];
  const colors = colorDetails.map(extractColorName).filter(Boolean);
  
  // æå–å°ºç æ•°æ®
  const sizes = Array.isArray(realData.sizes) ? realData.sizes : [];
  
  // åŠ¨æ€ç”Ÿæˆå˜ä½“åˆ—è¡¨ï¼ˆé¢œè‰² Ã— å°ºç ï¼‰
  const variants = [];
  if (colors.length > 0 && sizes.length > 0) {
    colors.forEach((color, colorIndex) => {
      const colorDetail = colorDetails[colorIndex] || {};
      const colorCode = extractColorCode(colorDetail) || `color_${colorIndex}`;
      
      sizes.forEach((size, sizeIndex) => {
        variants.push({
          variantId: `${productId}_${colorCode}_${size}`,
          colorName: color,
          colorCode: colorCode,
          sizeName: size,
          available: true, // æš‚æ—¶é»˜è®¤å¯ç”¨ï¼Œåç»­å¯æ ¹æ®åº“å­˜ä¿¡æ¯è°ƒæ•´
          price: realData.product?.price || '',
          sku: `${productId}-${colorCode}-${size}`
        });
      });
    });
  }
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
  
  console.log(`ğŸ”§ ä½¿ç”¨è¿‡æ»¤åçš„é¢œè‰²æ„å»ºå˜ä½“: ${filteredColors.length} ä¸ª`, filteredColors.map(c => c.code || c));
  
  const variantBundle = createDynamicVariants(
    productId,
    filteredColors,
    Array.isArray(realData.sizes) ? realData.sizes : []
  );

  // ğŸŒŸ GLM-4.6ä¿®å¾© + validColorCodes ä¸€è‡´æ€§é©—è­‰ï¼šåˆä½µå·²éæ¿¾çš„é¡è‰²ä¾†æº
  console.log(`ğŸ” buildFinalProductData é¡è‰²é©—è­‰:`);
  console.log(`   realData.colorMetadata: ${(realData.colorMetadata || []).length} å€‹`, (realData.colorMetadata || []).map(c => c.code));
  console.log(`   variantBundle.colors: ${variantBundle.colors.length} å€‹`, variantBundle.colors.map(c => c.code));
  
  const mergedColorMetadata = normalizeColorEntries([
    ...(realData.colorMetadata || []),
    ...variantBundle.colors
  ]);
  
  console.log(`   åˆä½µå¾Œé¡è‰²: ${mergedColorMetadata.length} å€‹`, mergedColorMetadata.map(c => c.code));

  // ç¢ºä¿åœ–ç‰‡åˆ†çµ„è‡³å°‘å­˜åœ¨ç©ºé™£åˆ—
  mergedColorMetadata.forEach(color => {
    if (!realData.imagesByColor[color.code]) {
      realData.imagesByColor[color.code] = [];
    }
  });

  const colorNames = mergedColorMetadata.map(color => color.name || color.code);
  const sizeList = variantBundle.sizes;

  const merged = {
    productId: productId,
    title: realData.product?.title || '',
    productUrl: argv.url, // ğŸŒŸ ç›´æ¥ä½¿ç”¨å‘½ä»¤è¡Œä¼ å…¥çš„URLï¼Œä¸å†æ”¹å†™
    description: realData.descriptionText || '', // ä½¿ç”¨çœŸå®æå–çš„æè¿°
    brand: realData.product?.brand || 'Callaway Golf',
    
<<<<<<< HEAD
    // ä½¿ç”¨çœŸå®æå–çš„é¢œè‰²å’Œå°ºç ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    colors: colorNames,
    sizes: sizeList,
    variants: variantBundle.variants,
    
    // ä½¿ç”¨çœŸå®æå–çš„å›¾ç‰‡å’Œå°ºç è¡¨
    rawImages: realData.rawImages,
    imagesByColor: realData.imagesByColor || {}, // ğŸŒŸ æ–°å¢ï¼šæŒ‰é¢œè‰²åˆ†ç»„çš„å›¾ç‰‡æ•°æ®  
    colorMetadata: mergedColorMetadata, // ğŸŒŸ GLM-4.6ä¿®å¾©ï¼šä½¿ç”¨åˆä½µå¾Œçš„é¡è‰²å…ƒæ•¸æ“š
    sizeChart: realData.sizeChartData,
=======
    // ä½¿ç”¨çœŸå®æå–çš„é¢œè‰²å’Œå°ºç 
    colors: colors.length > 0 ? colors : [],
    sizes: sizes.length > 0 ? sizes : [],
    variants: variants,
    
    // ä½¿ç”¨çœŸå®æå–çš„å›¾ç‰‡å’Œå°ºç è¡¨
    rawImages: realData.rawImages || [],
    imagesByColor: realData.imagesByColor || {},
    colorMetadata: realData.colorMetadata || [],
    sizeChart: realData.sizeChartData || null,
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
    
    // ä¿ç•™æ•°æ®æºä¿¡æ¯
    dataSources: realData.dataSources || []
  };
  
  console.log(colors.green(`âœ“ æœ€ç»ˆæ•°æ®æ„å»ºå®Œæˆ`));
  console.log(colors.gray(`  äº§å“æ ‡é¢˜: ${merged.title}`));
  console.log(colors.gray(`  æè¿°é•¿åº¦: ${merged.description.length}`));
  console.log(colors.gray(`  é¢œè‰²æ•°ç»„: [${merged.colors.join(', ')}] (${merged.colors.length}ä¸ª)`));
  console.log(colors.gray(`  å°ºç æ•°ç»„: [${merged.sizes.join(', ')}] (${merged.sizes.length}ä¸ª)`));
<<<<<<< HEAD
  console.log(colors.gray(`  å˜ä½“æ•°é‡: ${merged.variants.length}`));
=======
  console.log(colors.gray(`  å˜ä½“æ•°é‡: ${merged.variants.length} (åŠ¨æ€ç”Ÿæˆ)`));
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
  console.log(colors.gray(`  åŸå§‹å›¾ç‰‡: ${merged.rawImages.length} å¼ `));
  console.log(colors.gray(`  æŒ‰é¢œè‰²åˆ†ç»„: ${Object.keys(merged.imagesByColor).length} ä¸ªé¢œè‰²`));
  console.log(colors.gray(`  å°ºç è¡¨: ${merged.sizeChart ? 'å·²æå–' : 'æœªæ‰¾åˆ°'}`));
  
  // å¦‚æœæ²¡æœ‰æå–åˆ°é¢œè‰²æˆ–å°ºç ï¼Œè®°å½•è­¦å‘Š
  if (colors.length === 0) {
    console.log(colors.yellow(`âš ï¸ æœªæå–åˆ°é¢œè‰²ä¿¡æ¯ï¼Œè¿”å›ç©ºæ•°ç»„`));
  }
  if (sizes.length === 0) {
    console.log(colors.yellow(`âš ï¸ æœªæå–åˆ°å°ºç ä¿¡æ¯ï¼Œè¿”å›ç©ºæ•°ç»„`));
  }
  
  return merged;
}

/**
 * ä¸‹è½½å›¾ç‰‡
 */
/**
 * ğŸŒŸ GLM-4.6ä¿®å¤ç‰ˆï¼šä»é¢„æ³¨å…¥çš„ RSC chunk æ”¶é›†å™¨ä¸­æå–å›¾ç‰‡æ•°æ®
 */
async function extractImagesByColorInteraction(page, productId, productColors) {
  console.log(colors.blue(`ğŸ¨ å¼€å§‹æŠ“å– ${productId} æ‰€æœ‰é¢œè‰²çš„å•†å“ä¸»å›¾...`));
  console.log(colors.blue(`ğŸ” å¤šé¢œè‰²å¤„ç†æ¨¡å¼ï¼šæ‰«æâ†’ç‚¹å‡»â†’æå–â†’åˆ†ç»„`));

  try {
    // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
    await page.waitForTimeout(5000);
    
    // ğŸŒŸ æ­¥éª¤1ï¼šæ‰«ææ‰€æœ‰å¯ç”¨é¢œè‰²
    console.log(colors.blue(`ğŸ” æ‰«æé¡µé¢æ‰€æœ‰å¯ç”¨é¢œè‰²...`));
    
    const availableColors = await page.evaluate(() => {
      const colorsFound = [];
      
      // é¢œè‰²æŒ‰é’®çš„å¤šç§å¯èƒ½é€‰æ‹©å™¨ - å¢å¼ºç‰ˆ
      const colorButtonSelectors = [
        '[data-color]',
        '[data-variant]', 
        '[data-pid]',
        '[data-sku]',
        '.color-swatch',
        '.variation-attribute-value',
        '.swatch',
        'button[title*="1031"]',
        'button[title*="1010"]', 
        'button[title*="1030"]',
        'button[aria-label*="1031"]',
        'button[aria-label*="1010"]',
        'button[aria-label*="1030"]',
        'button[title*="WHITE"]',
        'button[title*="BLACK"]',
        'button[title*="NAVY"]',
        'button[title*="ãƒã‚¤ãƒ“ãƒ¼"]',
        'button[title*="ãƒ–ãƒ©ãƒƒã‚¯"]',
        'button[title*="ãƒ›ãƒ¯ã‚¤ãƒˆ"]',
        'button[class*="color"]',
        'button[class*="variant"]',
        'button[onclick*="1031"]',
        'button[onclick*="1010"]',
        'button[onclick*="1030"]',
        '[class*="cg-size"] button',
        '.product-variant button',
        '.option-selector button'
      ];
      
      for (const selector of colorButtonSelectors) {
        const elements = document.querySelectorAll(selector);
        if (elements.length > 0) {
          console.log(`æ‰¾åˆ°é¢œè‰²æŒ‰é’®é€‰æ‹©å™¨: ${selector}, æ•°é‡: ${elements.length}`);
          
          elements.forEach((element, index) => {
            // ä»å¤šç§å±æ€§ä¸­æå–é¢œè‰²ä»£ç  - å¢å¼ºç‰ˆ
            const possibleSources = [
              element.getAttribute('data-color'),
              element.getAttribute('data-variant'),
              element.getAttribute('data-pid'),
              element.getAttribute('data-sku'),
              element.getAttribute('data-value'),
              element.getAttribute('title'),
              element.getAttribute('aria-label'),
              element.getAttribute('onclick'),
              element.getAttribute('href'),
              element.textContent,
              element.innerHTML
            ].filter(Boolean);
            
            for (const source of possibleSources) {
              // å°è¯•æå–4ä½æ•°å­—ä»£ç ï¼ˆå¦‚1031ã€1010ã€1030ï¼‰
              const codeMatches = source.match(/\b(\d{4})\b/g);
              if (codeMatches) {
                codeMatches.forEach(code => {
                  // ğŸŒŸ GLM-4.6ä¿®å¾©ï¼šå…è¨±æ‰€æœ‰4ä½æ•¸å­—é¡è‰²ä»£ç¢¼ï¼Œä¸å†é™åˆ¶æ–¼ç™½åå–®
                  if (/^\d{4}$/.test(code)) {
                    colorsFound.push({
                      code: code,
                      element: element,
                      selector: selector,
                      index: index,
                      fullText: source,
                      source: 'attribute'
                    });
                  }
                });
              }
            }
            
            // å¦‚æœæ²¡æ‰¾åˆ°4ä½æ•°å­—ï¼Œå°è¯•é¢œè‰²åç§°æ˜ å°„
            const colorNameMapping = {
              'ãƒã‚¤ãƒ“ãƒ¼': '1031',
              'NAVY': '1031', 
              'ãƒ–ãƒ©ãƒƒã‚¯': '1010',
              'BLACK': '1010',
              'ãƒ›ãƒ¯ã‚¤ãƒˆ': '1030',
              'WHITE': '1030'
            };
            
            for (const source of possibleSources) {
              for (const [colorName, colorCode] of Object.entries(colorNameMapping)) {
                if (source.includes(colorName)) {
                  colorsFound.push({
                    code: colorCode,
                    element: element,
                    selector: selector,
                    index: index,
                    fullText: source,
                    source: 'name_mapping'
                  });
                }
              }
            }
          });
          
          // æ‰¾åˆ°é¢œè‰²æŒ‰é’®å°±åœæ­¢
          if (colorsFound.length > 0) break;
        }
      }
      
      // å»é‡ï¼ˆåŸºäºé¢œè‰²ä»£ç ï¼‰
      const uniqueColors = [];
      const seenCodes = new Set();
      
      colorsFound.forEach(color => {
        if (!seenCodes.has(color.code)) {
          seenCodes.add(color.code);
          uniqueColors.push(color);
        }
      });
      
      return uniqueColors;
    });
    
    console.log(colors.green(`âœ“ æ‰¾åˆ° ${availableColors.length} ä¸ªé¢œè‰²:`));
    availableColors.forEach(color => {
      console.log(colors.gray(`  - ${color.code}: ${color.fullText}`));
    });
    
    if (availableColors.length === 0) {
      console.log(colors.yellow(`âš ï¸ æœªæ‰¾åˆ°ä»»ä½•é¢œè‰²æŒ‰é’®ï¼Œè·³è¿‡é¢œè‰²å¤„ç†ï¼Œä¾èµ– normalizeColorEntries è™•ç†`));
      // ğŸŒŸ GLM-4.6ä¿®å¾©ï¼šä¸å†å¼·åˆ¶æ·»åŠ é è¨­é¡è‰²ï¼Œè®“ normalizeColorEntries çµ±ä¸€è™•ç†
    }
    
    // ğŸŒŸ æ­¥éª¤2ï¼šå¾ªç¯å¤„ç†æ¯ä¸ªé¢œè‰²
    const allColorResults = {};
    
    for (let i = 0; i < availableColors.length; i++) {
      const color = availableColors[i];
      console.log(colors.blue(`\nğŸ¨ å¤„ç†é¢œè‰² ${i + 1}/${availableColors.length}: ${color.code} (${color.fullText})`));
      
      // ç‚¹å‡»é¢œè‰²æŒ‰é’®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
      if (color.element) {
        console.log(colors.blue(`ğŸ–±ï¸ ç‚¹å‡»é¢œè‰²æŒ‰é’®: ${color.code}...`));
        
        const clickResult = await page.evaluate((colorData) => {
          // é‡æ–°æŸ¥æ‰¾å…ƒç´ ï¼ˆé¡µé¢å¯èƒ½å·²æ›´æ–°ï¼‰
          const elements = document.querySelectorAll(colorData.selector);
          if (elements[colorData.index]) {
            elements[colorData.index].click();
            return { success: true };
          }
          return { success: false, reason: 'Element not found' };
        }, color);
        
        if (clickResult.success) {
          console.log(colors.green(`âœ“ æˆåŠŸç‚¹å‡»é¢œè‰² ${color.code}`));
          await page.waitForTimeout(3000); // ç­‰å¾…è½®æ’­åˆ‡æ¢
        } else {
          console.log(colors.yellow(`âš ï¸ ç‚¹å‡»é¢œè‰²å¤±è´¥: ${clickResult.reason}`));
        }
      }
      
      // æå–è¯¥é¢œè‰²çš„å›¾ç‰‡
      console.log(colors.blue(`ğŸ” æå–é¢œè‰² ${color.code} çš„è½®æ’­å›¾ç‰‡...`));
      
      const colorImageData = await page.evaluate(() => {
        console.log('[è½®æ’­æå–] å¼€å§‹ä»è½®æ’­å®¹å™¨æå–å›¾ç‰‡...');
      
      const allImages = [];
      const excludeKeywords = ['size', 'ã‚µã‚¤ã‚º', 'wash', 'icon', 'logo', 'ç´ æ'];
      
      // æŸ¥æ‰¾è½®æ’­å®¹å™¨çš„å¤šç§å¯èƒ½é€‰æ‹©å™¨
      const carouselSelectors = [
        '.slick-slide img',
        '[class*="product-image"] img',
        '[class*="carousel"] img',
        '[class*="slider"] img',
        '[class*="gallery"] img',
        '.product-images img',
        '.main-image img',
        '.hero-image img'
      ];
      
      let foundImages = [];
      
      for (const selector of carouselSelectors) {
        const imgs = document.querySelectorAll(selector);
        if (imgs.length > 0) {
          console.log(`æ‰¾åˆ°è½®æ’­é€‰æ‹©å™¨: ${selector}, å›¾ç‰‡æ•°é‡: ${imgs.length}`);
          foundImages = Array.from(imgs);
          break;
        }
      }
      
      // å¦‚æœè½®æ’­å®¹å™¨æ‰¾ä¸åˆ°ï¼Œå›é€€åˆ°æ‰€æœ‰äº§å“å›¾ç‰‡
      if (foundImages.length === 0) {
        console.log('æœªæ‰¾åˆ°è½®æ’­å®¹å™¨ï¼Œä½¿ç”¨æ‰€æœ‰imgæ ‡ç­¾');
        foundImages = Array.from(document.querySelectorAll('img'));
      }
      
      foundImages.forEach((img, index) => {
        const src = img.src || '';
        const dataSrc = img.getAttribute('data-src') || '';
        const srcset = img.srcset || '';
        const alt = img.alt || '';
        
        // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„å›¾ç‰‡æº
        const imageSources = [src, dataSrc];
        
        // å¤„ç†srcsetï¼ˆåŒ…å«å¤šä¸ªå°ºå¯¸ï¼‰
        if (srcset) {
          const srcsetParts = srcset.split(',');
          srcsetParts.forEach(part => {
            const url = part.trim().split(' ')[0];
            const width = part.trim().split(' ')[1] || '0w';
            imageSources.push({ url, width });
          });
        }
        
        imageSources.forEach(source => {
          let url = '';
          let width = '0w';
          
          if (typeof source === 'string') {
            url = source;
          } else if (source && source.url) {
            url = source.url;
            width = source.width;
          }
          
          // ğŸŒŸ åªå¤„ç†åŒ…å«webdamdbæˆ–_next/imageçš„URLï¼Œä¸”å¿…é¡»åŒ…å«1280_å‰ç¼€
          if (url && (url.includes('webdamdb.com') || url.includes('_next/image'))) {
            
            // ğŸŒŸ æ£€æŸ¥æ˜¯å¦ä¸º1280_å‰ç¼€çš„ä¸»å›¾
            let isMainImage = false;
            if (url.includes('_next/image')) {
              try {
                const urlObj = new URL(url, 'https://www.callawaygolf.jp');
                const actualImageUrl = urlObj.searchParams.get('url');
                if (actualImageUrl) {
                  const decodedUrl = decodeURIComponent(actualImageUrl);
                  isMainImage = decodedUrl.includes('1280_');
                }
              } catch (e) {
                // URLè§£æå¤±è´¥ï¼Œè·³è¿‡
              }
            } else if (url.includes('webdamdb.com')) {
              isMainImage = url.includes('1280_');
            }
            
            // ğŸŒŸ åªä¿ç•™1280_å‰ç¼€çš„ä¸»å›¾
            if (!isMainImage) {
              return; // è·³è¿‡éä¸»å›¾
            }
            
            // è¿‡æ»¤æ‰åŒ…å«æ’é™¤å…³é”®è¯çš„å›¾ç‰‡
            const shouldExclude = excludeKeywords.some(keyword => 
              url.toLowerCase().includes(keyword.toLowerCase()) ||
              alt.toLowerCase().includes(keyword.toLowerCase())
            );
            
            if (!shouldExclude) {
              // ğŸŒŸ è¡¥å…¨ä¸ºç»å¯¹URL
              let finalUrl = url;
              if (url.startsWith('/_next/')) {
                finalUrl = 'https://www.callawaygolf.jp' + url;
              } else if (!url.startsWith('http')) {
                finalUrl = 'https://www.callawaygolf.jp' + url;
              }
              
              // æå–widthæ•°å€¼ç”¨äºæ’åº
              const widthNum = parseInt(width.replace('w', '')) || 0;
              
              allImages.push({
                originalUrl: url,
                finalUrl: finalUrl, // ç»å¯¹URL
                source: 'carousel',
                index: index,
                alt: alt,
                className: img.className || '',
                width: widthNum,
                widthStr: width
              });
            }
          }
        });
      });
      
      // ğŸŒŸ æŒ‰åŸºç¡€å›¾ç‰‡åˆ†ç»„ï¼Œæ¯ç»„åªä¿ç•™w=3000ç‰ˆæœ¬
      const imageGroups = {};
      allImages.forEach(imgData => {
        // æå–åŸºç¡€URLï¼ˆä»webdamdbè·¯å¾„ä¸­æå–æ–‡ä»¶åä½œä¸ºkeyï¼‰
        let baseKey = '';
        
        if (imgData.finalUrl.includes('_next/image?')) {
          try {
            const urlObj = new URL(imgData.finalUrl);
            const actualImageUrl = urlObj.searchParams.get('url');
            if (actualImageUrl) {
              const decodedUrl = decodeURIComponent(actualImageUrl);
              // ä»webdamdb URLä¸­æå–æ–‡ä»¶åï¼ˆå¦‚1280_ANQKK9g9LUW02Aay.jpgï¼‰
              const matches = decodedUrl.match(/1280_([^?]+)/);
              if (matches) {
                baseKey = matches[1]; // æå–æ–‡ä»¶æ ‡è¯†ç¬¦
              }
            }
          } catch (e) {
            console.log('URLè§£æå¤±è´¥:', imgData.finalUrl);
          }
        }
        
        if (baseKey) {
          if (!imageGroups[baseKey]) {
            imageGroups[baseKey] = [];
          }
          imageGroups[baseKey].push(imgData);
        }
      });
      
      // ğŸŒŸ æ¯ç»„åªä¿ç•™w=3000çš„ç‰ˆæœ¬
      const finalImages = [];
      Object.values(imageGroups).forEach(group => {
        // ä¼˜å…ˆé€‰æ‹©w=3000çš„ç‰ˆæœ¬
        const w3000Version = group.find(img => img.finalUrl.includes('w=3000'));
        if (w3000Version) {
          finalImages.push(w3000Version);
        } else {
          // å¦‚æœæ²¡æœ‰w=3000ï¼ŒæŒ‰widthé™åºæ’åºå–æœ€å¤§çš„
          group.sort((a, b) => b.width - a.width);
          finalImages.push(group[0]);
        }
      });
      
      // æŒ‰åŸå§‹é¡ºåºæ’åº
      finalImages.sort((a, b) => a.index - b.index);
        
        console.log(`[è½®æ’­æå–] æ€»è®¡æ‰¾åˆ° ${allImages.length} å¼ å›¾ç‰‡ï¼Œå»é‡å ${finalImages.length} å¼ `);
        
        return finalImages;
      });
      
      console.log(colors.green(`âœ“ é¢œè‰² ${color.code} å›¾ç‰‡æå–å®Œæˆ`));
      console.log(colors.gray(`  æ€»è®¡æ‰¾åˆ°å›¾ç‰‡: ${colorImageData.length}`));
      
      // å–å‰12å¼ å›¾ç‰‡
      const colorFinalImages = colorImageData.slice(0, 12);
      
      // ä¿å­˜è¯¥é¢œè‰²çš„ç»“æœ
      allColorResults[color.code] = {
        colorCode: color.code,
        colorName: color.fullText,
        images: colorFinalImages,
        count: colorFinalImages.length
      };
      
      console.log(colors.blue(`\nğŸ“‹ é¢œè‰² ${color.code} çš„å›¾ç‰‡URLåˆ—è¡¨ (${colorFinalImages.length}å¼ ):`));
      colorFinalImages.forEach((img, index) => {
        console.log(colors.gray(`  ${index + 1}. ${img.finalUrl}`));
      });
    }
    
    // ğŸŒŸ æ­¥éª¤3ï¼šæ±‡æ€»æ‰€æœ‰é¢œè‰²çš„ç»“æœ
    console.log(colors.blue(`\nğŸ‰ æ‰€æœ‰é¢œè‰²å¤„ç†å®Œæˆï¼Œç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š...`));
    
    const totalImages = Object.values(allColorResults).reduce((sum, colorData) => sum + colorData.count, 0);
    const processedColors = Object.keys(allColorResults).length;
    
    console.log(colors.green(`âœ“ å¤„ç†å®Œæˆç»Ÿè®¡:`));
    console.log(colors.gray(`  é¢œè‰²æ€»æ•°: ${processedColors}`));
    console.log(colors.gray(`  å›¾ç‰‡æ€»æ•°: ${totalImages}`));
    
    // ğŸŒŸ æŒ‰é¢œè‰²è¾“å‡ºè¯¦ç»†URLåˆ—è¡¨
    Object.entries(allColorResults).forEach(([colorCode, colorData]) => {
      console.log(colors.blue(`\nğŸ“‹ ${colorCode} (${colorData.colorName}) - ${colorData.count}å¼ å›¾ç‰‡:`));
      colorData.images.forEach((img, index) => {
        console.log(`${index + 1}. ${img.finalUrl}`);
      });
    });
    
    console.log(colors.yellow(`\nâš ï¸ è¯·ç¡®è®¤ä»¥ä¸Šæ‰€æœ‰é¢œè‰²çš„URLåˆ—è¡¨ï¼Œç¡®è®¤OKåæ‰ä¼šå†™å…¥JSONå¹¶è¿›è¡Œä¸‹ä¸€æ­¥å¤„ç†`));
    
    // ğŸŒŸ è½¬æ¢ä¸ºfinalImagesByColorç»“æ„
    const finalImagesByColor = {};
    const allImages = [];
    const colorMetadata = [];
    
    // è½¬æ¢æ¯ä¸ªé¢œè‰²çš„å›¾ç‰‡æ•°æ®
    Object.entries(allColorResults).forEach(([colorCode, colorData]) => {
      const finalImagesForColor = colorData.images.map((img, index) => ({
        originalUrl: img.originalUrl,
        url1080: img.finalUrl, // ä¿æŒw=3000ä¸åšæ›¿æ¢
        colorCode: colorCode,
        colorName: colorData.colorName,
        index: index
      }));
      
      finalImagesByColor[colorCode] = finalImagesForColor;
      allImages.push(...finalImagesForColor);
      
      colorMetadata.push({
        code: colorCode,
        name: colorData.colorName,
        displayName: colorData.colorName
      });
    });
    
    // æŒ‰ç…§ä»»åŠ¡è¦æ±‚è¿”å›çš„ç»“æ„
    return {
      imagesByColor: finalImagesByColor,
      allImages: allImages,
      totalImages: allImages.length,
      filteredCount: allImages.length,
      colorMetadata: colorMetadata
    };
    
  } catch (error) {
    console.error(colors.red(`âœ— å¤šé¢œè‰²å›¾ç‰‡æŠ“å–å¤±è´¥: ${error.message}`));
    console.log(colors.yellow('  å›é€€åˆ°å•é¢œè‰²é»˜è®¤å¤„ç†...'));
    
    // å›é€€æ–¹æ¡ˆï¼šåªå¤„ç†é»˜è®¤é¢œè‰²
    return {
      status: 'error',
      byColor: {
        '1031': {
          colorCode: '1031',
          colorName: 'DEFAULT',
          images: [],
          count: 0
        }
      },
      totalImages: 0,
      totalColors: 1,
      error: error.message
    };
  }
}

/**
<<<<<<< HEAD
 * å¤„ç†å›¾ç‰‡ï¼šä¸‹è½½ã€ä¸Šä¼ ã€åˆ†ç»„ï¼ˆä½¿ç”¨ colorMetadata ä¼˜åŒ–ç‰ˆï¼‰
 */
async function cleanupTempDir() {
  try {
    const files = await fs.readdir(TEMP_DIR);
    for (const file of files) {
      await fs.unlink(path.join(TEMP_DIR, file));
    }
    await fs.rmdir(TEMP_DIR);
    console.log(colors.gray('âœ“ æ¸…ç†ä¸´æ—¶ç›®å½•'));
  } catch (error) {
    // å¿½ç•¥æ¸…ç†å¤±è´¥
  }
}

/**
 * ğŸŒŸ ä¸»æŠ“å–å‡½æ•°ï¼ˆå®Œå…¨ä¿®å¤ç‰ˆï¼‰
 */
async function scrapeProductDetail() {
  const startTime = Date.now();
  const productId = argv.productId;
  const url = argv.url;
  
  console.log(colors.blue('ğŸš€ CallawayJP å•†å“è¯¦æƒ…æŠ“å– - v5.0 å®Œå…¨ä¿®å¤ç‰ˆ'));
  console.log(colors.gray(`ğŸ¯ ç›®æ ‡URL: ${url}`));
  console.log(colors.gray(`ğŸ“¦ äº§å“ID: ${productId}`));
  
  if (!url || !productId) {
    throw new Error('ç¼ºå°‘å¿…è¦å‚æ•°ï¼š--url å’Œ --product-id');
  }
  
  let browser;
  let ossClient;
  
  try {
    // åˆå§‹åŒ– OSS å®¢æˆ·ç«¯
    ossClient = await initOSSClient();
    
    // åˆå§‹åŒ–æµè§ˆå™¨
    console.log(colors.blue('ğŸŒ å¯åŠ¨æµè§ˆå™¨...'));
    const playwright = await import('playwright');
    browser = await playwright.chromium.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    });
    
    const page = await setupPage(context);
    
    // ğŸŒŸ RSC Hook è®¾ç½®ï¼ˆä¼˜åŒ–ç‰ˆï¼‰- è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç­–ç•¥
    console.log(colors.blue('ğŸ”§ è®¾ç½® RSC Chunk æ”¶é›†å™¨...'));
    
    // é¢„æ³¨å…¥æ”¶é›†å™¨åˆ°é¡µé¢
    await page.addInitScript(`
      window._rscChunkCollector = {
        chunks: [],
        rawChunks: [],
        hookAttempts: 0,
        hookSuccess: false,
        
        // RSC Chunk å¤„ç†å™¨
        processChunk: function(chunkId, payload) {
          this.rawChunks.push({ chunkId, payload, timestamp: Date.now() });
          
          let payloadStr = '';
          if (typeof payload === 'string') {
            payloadStr = payload;
          } else if (payload && typeof payload === 'object') {
            try {
              payloadStr = JSON.stringify(payload);
            } catch (e) {
              payloadStr = String(payload);
            }
          } else {
            payloadStr = String(payload || '');
          }
          
          this.chunks.push({ chunkId, payload: payloadStr });
          
          // å°è¯•æå– productDetail æ•°æ®
          try {
            // RSC payload å¯èƒ½åŒ…å«è½¬ä¹‰å­—ç¬¦ï¼Œéœ€è¦å¤„ç†
            let cleanPayload = payloadStr;
            if (cleanPayload.includes('\\\\u003c')) {
              cleanPayload = cleanPayload.replace(/\\\\u003c/g, '<').replace(/\\\\u003e/g, '>');
            }
            
            // æŸ¥æ‰¾ productDetail æ•°æ®
            if (cleanPayload.includes('productDetail') && cleanPayload.includes('imageGroups')) {
              try {
                const productDetailMatch = cleanPayload.match(/"productDetail"\\s*:\\s*(\\{[\\s\\S]*?\\})(?=\\s*[,}])/);
                if (productDetailMatch) {
                  const productDetailStr = productDetailMatch[1]
                    .replace(/\\\\"/g, '"')
                    .replace(/\\\\n/g, '\\n')
                    .replace(/\\\\r/g, '\\r')
                    .replace(/\\\\t/g, '\\t');
                  
                  const productDetail = JSON.parse(productDetailStr);
                  if (productDetail.imageGroups) {
                    window._rscChunkCollector.productDetail = productDetail;
                    console.log('[RSC] âœ“ æˆåŠŸæå– productDetail æ•°æ®');
                  }
                }
              } catch (e) {
                console.log('[RSC] productDetail è§£æå¤±è´¥:', e.message);
              }
            }
          } catch (e) {
            // å¿½ç•¥è§£æé”™è¯¯
          }
        }
      };
      
      // Hook è®¾ç½®å‡½æ•°
      function setupHook() {
        window._rscChunkCollector.hookAttempts++;
        
        if (window.self && window.self.__next_f) {
          const originalPush = window.self.__next_f.push;
          if (originalPush) {
            window.self.__next_f.push = function(...args) {
              if (args.length >= 2) {
                const [chunkId, payload] = args;
                window._rscChunkCollector.processChunk(chunkId, payload);
              }
              return originalPush.apply(this, args);
            };
            
            window._rscChunkCollector.hookSuccess = true;
            console.log('[RSC Hook] âœ“ æˆåŠŸè®¾ç½® __next_f.push ä»£ç†');
            return true;
          }
        }
        return false;
      }
      
      // ç«‹å³å°è¯•è®¾ç½®
      setupHook();
      
      // é¡µé¢åŠ è½½åå†æ¬¡å°è¯•
      document.addEventListener('DOMContentLoaded', setupHook);
      
      // å®šæ—¶é‡è¯•
      const retryInterval = setInterval(() => {
        if (!window._rscChunkCollector.hookSuccess && window._rscChunkCollector.hookAttempts < 5) {
          setupHook();
        } else {
          clearInterval(retryInterval);
        }
      }, 1000);
    `);
    
    // å¯¼èˆªåˆ°é¡µé¢
    console.log(colors.blue(`ğŸ”— å¯¼èˆªåˆ°äº§å“é¡µé¢...`));
    await page.goto(url, { 
      waitUntil: 'networkidle',
      timeout: 60000 
    });
    
    // ç­‰å¾…é¡µé¢æ¸²æŸ“å’Œ RSC æ•°æ®åŠ è½½
    await page.waitForTimeout(8000);
    
    // 1. æå–çœŸå®äº§å“æ•°æ®
    const realData = await extractRealProductData(page, productId);
    
    // 2. åˆå¹¶çœŸå®æ•°æ®å¹¶ç”ŸæˆåŠ¨æ€å˜ä½“
    const productData = buildFinalProductData(realData, productId);
    
    console.log(colors.magenta('=== æ•°æ®æå–å®Œæˆ ===\\n'));
    
    // 4. æŒ‰å˜ä½“åˆ†ç»„å¤„ç†å›¾ç‰‡
    const processedImages = await processImagesWithVariantGrouping(productData, ossClient);
    
    // ğŸŒŸ æ­¥éª¤2: æå–å’Œè¿‡æ»¤å›¾ç‰‡
    const candidateImages = [];
    let filteredCount = 0;
    
    validImageGroups.forEach(group => {
      if (group.images && Array.isArray(group.images)) {
        group.images.forEach((img, imgIndex) => {
          const imgUrl = img.url || img.src || '';
          const imgAlt = img.alt || '';
          
          // ğŸš¨ ä¸¥æ ¼è¿‡æ»¤è§„åˆ™ - URL å’Œ alt åŒæ—¶æ£€æŸ¥
          const excludeKeywords = [
            'size', 'ã‚µã‚¤ã‚º', 'å°ºå¯¸', 'chart', 'è¡¨',
            'æ´—æ¿¯', 'wash', 'care', 'ç´ æ', 'material',
            'icon', 'logo', 'symbol', 'guide', 'fit', 'illustration'
          ];
          
          const searchText = (imgUrl + ' ' + imgAlt).toLowerCase();
          const hasExcludeKeyword = excludeKeywords.some(keyword => 
            searchText.includes(keyword.toLowerCase())
          );
          
          if (hasExcludeKeyword) {
            console.log(`    âœ— è¿‡æ»¤å…³é”®è¯: ${imgAlt}`);
            filteredCount++;
            return;
          }
          
          // ğŸš¨ åªä¿ç•™ .jpg/.jpeg å›¾ç‰‡
          if (!imgUrl.match(/\.(jpg|jpeg)(\?|$)/i)) {
            console.log(`    âœ— è¿‡æ»¤éJPG: ${imgUrl}`);
            filteredCount++;
            return;
          }
          
          // ğŸš¨ æ£€æŸ¥å›¾ç‰‡å°ºå¯¸ (æœ‰å°ºå¯¸ä¿¡æ¯æ‰æ£€æŸ¥)
          const width = img.width || img.w || 0;
          const height = img.height || img.h || 0;
          if ((width > 0 && width < 800) || (height > 0 && height < 800)) {
            console.log(`    âœ— è¿‡æ»¤å°å°ºå¯¸: ${width}x${height}`);
            filteredCount++;
            return;
          }
          
          // ğŸš¨ å¿…é¡»æ˜¯ webdamdb é“¾æ¥
          if (!imgUrl.includes('webdamdb.com')) {
            console.log(`    âœ— è¿‡æ»¤éwebdamdb: ${imgUrl}`);
            filteredCount++;
            return;
          }
          
          // âœ… é€šè¿‡æ‰€æœ‰è¿‡æ»¤æ¡ä»¶
          candidateImages.push({
            originalUrl: imgUrl.split('?')[0], // ç§»é™¤å‚æ•°çš„åŸå§‹URL
            url1080: `${imgUrl.split('?')[0]}?imwidth=1080&imheight=1080&impolicy=Resize&imformat=jpg`,
            alt: imgAlt,
            colorCode: '1031',
            colorName: 'WHITE/NAVY',
            index: candidateImages.length
          });
          
          console.log(`    âœ“ å€™é€‰å›¾ç‰‡ ${candidateImages.length}: ${imgAlt}`);
        });
      }
    });
    
    // ğŸŒŸ æ­¥éª¤3: å»é‡å¹¶ä¿ç•™å‰12å¼ 
    const uniqueImages = [];
    const seenUrls = new Set();
    
    candidateImages.forEach(img => {
      if (!seenUrls.has(img.originalUrl)) {
        seenUrls.add(img.originalUrl);
        uniqueImages.push({
          ...img,
          index: uniqueImages.length
        });
      }
    });
    
    const finalImages = uniqueImages.slice(0, 12);
    
    console.log(colors.blue('ğŸ“Š å›¾ç‰‡ç­›é€‰ç»“æœ:'));
    console.log(colors.gray(`  å€™é€‰å›¾ç‰‡: ${candidateImages.length} å¼ `));
    console.log(colors.gray(`  è¿‡æ»¤æ•°é‡: ${filteredCount} å¼ `));
    console.log(colors.gray(`  å»é‡å: ${uniqueImages.length} å¼ `));
    console.log(colors.gray(`  æœ€ç»ˆä¿ç•™: ${finalImages.length} å¼ `));
    
    if (finalImages.length < 12) {
      console.log(colors.yellow(`âš ï¸ å›¾ç‰‡æ•°é‡ä¸è¶³12å¼ ï¼Œå®é™…è·å¾— ${finalImages.length} å¼ `));
    }
    
    // è¿”å›è°ƒè¯•ä¿¡æ¯
    return {
      success: true,
      productDetailFound: !!foundProductDetail,
      productDetail: foundProductDetail,
      debugInfo: debugInfo
    };
    
  } catch (error) {
    console.error(colors.red(`âœ— RSC å›¾ç‰‡æŠ“å–å¤±è´¥: ${error.message}`));
    console.log(colors.yellow('  å›é€€åˆ°ç©ºç»“æ„...'));
    
    // å›é€€æ–¹æ¡ˆï¼šåŸºäºè¾“å…¥é¢œè‰²ç”Ÿæˆç©ºç»“æ„
    const inputColorList = Array.isArray(productColors) ? productColors : [];
    const fallbackImagesByColor = {};
    const fallbackColorMetadata = [];
    
    inputColorList.forEach((color, index) => {
      const colorCode = extractColorCode(color) || `color_${index}`;
      const colorName = extractColorName(color) || colorCode;
      
      fallbackImagesByColor[colorCode] = [];
      fallbackColorMetadata.push({
        code: colorCode,
        name: colorName,
        displayName: colorName,
        rawValue: color
      });
    });
    
    return {
      imagesByColor: fallbackImagesByColor,
      allImages: [],
      totalImages: 0,
      filteredCount: 0,
      colorMetadata: fallbackColorMetadata
    };
  }
}

/**
 * å¤„ç†å›¾ç‰‡ï¼šä¸‹è½½ã€ä¸Šä¼ ã€åˆ†ç»„ï¼ˆä½¿ç”¨ colorMetadata ä¼˜åŒ–ç‰ˆï¼‰
 */
async function processImagesWithVariantGrouping(productData, ossClient) {
  console.log(colors.blue(`ğŸ–¼ï¸  å¤„ç†å•†å“å›¾ç‰‡ (GLM-4.6ä¼˜åŒ–ç‰ˆ)...`));

  const imagesByColor = productData.imagesByColor || {};
  const metadataSource = Array.isArray(productData.colorMetadata) && productData.colorMetadata.length > 0
    ? productData.colorMetadata
    : Array.isArray(productData.colors) && productData.colors.length > 0
      ? productData.colors
      : Object.keys(imagesByColor);

  let colorMetadata = normalizeColorEntries(metadataSource);
  const extraColors = Object.keys(imagesByColor).filter(code => !colorMetadata.find(color => color.code === code));
  if (extraColors.length > 0) {
    colorMetadata = colorMetadata.concat(normalizeColorEntries(extraColors));
  }

  const totalImages = Object.values(imagesByColor).reduce((total, images) => total + (Array.isArray(images) ? images.length : 0), 0);
  console.log(colors.gray(`ğŸ“¸ é¡µé¢è¿”å›å›¾ç‰‡æ€»æ•°: ${totalImages}`));

  if (totalImages === 0) {
    console.log(colors.yellow('âš ï¸ æ²¡æœ‰å›¾ç‰‡éœ€è¦å¤„ç†'));
    return {
      product: [],
      variants: {},
      ossLinks: {
        productImages: [],
        variantImages: {}
      },
      totalImages: 0,
      ossUploadCount: 0,
      uploadErrors: []
    };
  }

  await ensureDir(TEMP_DIR);

  const processedImages = {
    product: [],
    variants: {},
    ossLinks: {
      productImages: [],
      variantImages: {}
    },
    totalImages: 0,
    ossUploadCount: 0,
    uploadErrors: []
  };

  const firstColorCode = colorMetadata[0]?.code;

  colorMetadata.forEach(meta => {
    const variantKey = `${productData.productId}_${meta.code}`;
    processedImages.variants[variantKey] = [];
    processedImages.ossLinks.variantImages[variantKey] = [];
  });

  let globalImageIndex = 0;

  for (const [colorCode, colorImagesRaw] of Object.entries(imagesByColor)) {
    const colorImages = Array.isArray(colorImagesRaw) ? colorImagesRaw : [];
    const colorMeta = colorMetadata.find(m => m.code === colorCode) || { code: colorCode, name: colorCode };
    const colorName = colorMeta.name || colorCode;
    const variantKey = `${productData.productId}_${colorMeta.code}`;

    if (!processedImages.variants[variantKey]) {
      processedImages.variants[variantKey] = [];
      processedImages.ossLinks.variantImages[variantKey] = [];
    }

    console.log(colors.blue(`ğŸ¨ å¤„ç† ${colorName} (${colorMeta.code}) - ${colorImages.length} å¼ å›¾ç‰‡`));

    for (let i = 0; i < colorImages.length; i++) {
      const image = colorImages[i] || {};
      const candidateUrl = image.url1080 || image.originalUrl || image.url || image.src;

      if (!candidateUrl) {
        console.log(colors.yellow(`  âš ï¸ è·³è¿‡ç¼ºå°‘URLçš„å›¾ç‰‡ [${colorMeta.code}] index=${i}`));
        continue;
      }

      let ossUrl = null;
      let ossPath = null;

      try {
        if (argv.dryRun) {
          ossUrl = candidateUrl;
          console.log(colors.yellow(`  ğŸ”„ å¹²è¿è¡Œ: ${colorName}[${i}] ä½¿ç”¨åŸå§‹URL`));
        } else {
          const normalizedUrl = candidateUrl;
          const imageExt = path.extname(new URL(normalizedUrl).pathname) || '.jpg';
          const tempFileName = `${productData.productId}_${colorMeta.code}_${i}${imageExt}`;
          const tempPath = path.join(TEMP_DIR, tempFileName);

          console.log(colors.gray(`  â¬‡ï¸ ä¸‹è½½ ${colorName}[${i + 1}/${colorImages.length}]: ${normalizedUrl}`));
          await downloadImage(normalizedUrl, tempPath);

          let finalPath = tempPath;
          if (!imageExt.match(/\.(jpg|jpeg)$/i)) {
            finalPath = tempPath.replace(/\.[^.]+$/, '.jpg');
            await fs.rename(tempPath, finalPath);
          }

          ossPath = `callaway/${productData.productId}/${colorMeta.code}/${i}.jpg`;
          ossUrl = await uploadImageToOSS(ossClient, finalPath, ossPath, 3);

          try {
            await fs.unlink(finalPath);
          } catch {
            // å¿½ç•¥åˆ é™¤å¤±è´¥
          }
        }

        if (!ossUrl) {
          continue;
        }

        if (ossClient && !argv.dryRun && ossPath) {
          try {
            await ossClient.head(ossPath);
            console.log(colors.green(`  âœ“ ä¸Šä¼ æˆåŠŸ: ${colorName}[${i}]`));
          } catch (ossVerifyError) {
            console.error(colors.red(`  âœ— OSSéªŒè¯å¤±è´¥: ${ossVerifyError.message}`));
            processedImages.uploadErrors.push({
              url: candidateUrl,
              error: `OSSéªŒè¯å¤±è´¥: ${ossVerifyError.message}`,
              colorCode: colorMeta.code,
              type: 'oss_verification_failed'
            });
            continue;
          }
        } else if (argv.dryRun) {
          console.log(colors.green(`  âœ“ å¹²è¿è¡Œç¡®è®¤: ${colorName}[${i}]`));
        }

        const processedImage = {
          originalUrl: image.originalUrl || candidateUrl,
          ossUrl,
          alt: image.alt || '',
          type: 'product_1080',
          index: globalImageIndex++,
          colorCode: colorMeta.code,
          colorName,
          size: '1080x1080'
        };

        processedImages.variants[variantKey].push(processedImage);
        processedImages.ossLinks.variantImages[variantKey].push(ossUrl);

        if (firstColorCode && colorMeta.code === firstColorCode) {
          processedImages.product.push(processedImage);
          processedImages.ossLinks.productImages.push(ossUrl);
        }

        processedImages.ossUploadCount++;
      } catch (error) {
        console.error(colors.red(`  âœ— å¤„ç†å›¾ç‰‡å¤±è´¥ ${candidateUrl}: ${error.message}`));

        let errorType = 'download_or_upload_1080';
        if (error.message.includes('HTTP 429')) {
          errorType = 'http_429_rate_limit';
        } else if (error.message.includes('HTTP 404')) {
          errorType = 'http_404_not_found';
        } else if (error.message.includes('timeout')) {
          errorType = 'download_timeout';
        }

        processedImages.uploadErrors.push({
          url: candidateUrl,
          error: error.message,
          colorCode: colorMeta.code,
          type: errorType
        });
      }
    }
  }

  processedImages.totalImages = Object.values(processedImages.variants).reduce((sum, arr) => sum + arr.length, 0);

  console.log(colors.green(`âœ“ å›¾ç‰‡å¤„ç†å®Œæˆ`));
  console.log(colors.blue(`ğŸ“Š ç»Ÿè®¡ä¿¡æ¯:`));
  console.log(colors.gray(`  å®é™…å›¾ç‰‡æ•°: ${processedImages.totalImages} å¼ `));
  console.log(colors.gray(`  è®°å½•ä¸»å›¾: ${processedImages.product.length} å¼ `));
  console.log(colors.gray(`  ä¸Šä¼ /ç¡®è®¤æ¬¡æ•°: ${processedImages.ossUploadCount}`));
  console.log(colors.gray(`  é”™è¯¯è®°å½•: ${processedImages.uploadErrors.length}`));

  Object.entries(processedImages.variants).forEach(([variantKey, images]) => {
    const count = images.length;
    if (count === 0) {
      console.log(colors.yellow(`  âš ï¸ ${variantKey}: æœªæŠ“åˆ°å›¾ç‰‡`));
    } else {
      console.log(colors.gray(`  ${variantKey}: ${count} å¼ `));
    }
  });

  if (processedImages.uploadErrors.length > 0) {
    console.log(colors.red(`âš ï¸ å¤±è´¥å›¾ç‰‡æ±‡æ€» (${processedImages.uploadErrors.length} å¼ ):`));
    const errorsByType = {};
    processedImages.uploadErrors.forEach(err => {
      if (!errorsByType[err.type]) {
        errorsByType[err.type] = [];
      }
      errorsByType[err.type].push(err);
    });

    Object.entries(errorsByType).forEach(([type, errors]) => {
      console.log(colors.red(`  ${type}: ${errors.length} å¼ `));
      errors.slice(0, 3).forEach(err => {
        console.log(colors.red(`    - [${err.colorCode}] ${err.url.substring(0, 80)}${err.url.length > 80 ? '...' : ''}`));
      });
      if (errors.length > 3) {
        console.log(colors.red(`    ... è¿˜æœ‰ ${errors.length - 3} å¼ ç›¸åŒé”™è¯¯`));
      }
    });
  }

  return processedImages;
}

/**
 * æ¸…ç†ä¸´æ—¶ç›®å½•
 */
async function cleanupTempDir() {
  try {
    const files = await fs.readdir(TEMP_DIR);
    for (const file of files) {
      await fs.unlink(path.join(TEMP_DIR, file));
    }
    await fs.rmdir(TEMP_DIR);
    console.log(colors.gray('âœ“ æ¸…ç†ä¸´æ—¶ç›®å½•'));
  } catch (error) {
    // å¿½ç•¥æ¸…ç†å¤±è´¥
  }
}

/**
=======
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
 * ğŸŒŸ ä¸»æŠ“å–å‡½æ•°ï¼ˆå®Œå…¨ä¿®å¤ç‰ˆï¼‰
 */
async function scrapeProductDetail() {
  const startTime = Date.now();
  const productId = argv.productId;
  const url = argv.url;
  
  console.log(colors.blue('ğŸš€ CallawayJP å•†å“è¯¦æƒ…æŠ“å– - v5.0 å®Œå…¨ä¿®å¤ç‰ˆ'));
  console.log(colors.gray(`URL: ${url}`));
  console.log(colors.gray(`Product ID: ${productId}`));
  console.log(colors.magenta('ä¿®å¤é‡ç‚¹: 3è‰²Ã—4ç =12å˜ä½“ + çœŸå®æè¿° + å›¾ç‰‡åˆ†ç»„ + é£ä¹¦å…¼å®¹'));
  console.log('');
  
  let browser;

  try {
    
    // å¯åŠ¨æµè§ˆå™¨
    console.log(colors.blue('ğŸŒ å¯åŠ¨æµè§ˆå™¨...'));
    browser = await chromium.launch(BROWSER_OPTIONS);
    
    const context = await browser.newContext(CONTEXT_OPTIONS);
    const page = await setupPage(context);
    
    // ğŸŒŸ å…³é”®ä¿®å¤1: åœ¨é¡µé¢åŠ è½½å‰æ³¨å…¥ RSC chunk æ‹¦æˆªè„šæœ¬ï¼ˆä½¿ç”¨ defineProperty ä»£ç†ï¼‰
    console.log(colors.blue('ğŸ” æ³¨å…¥å¢å¼ºç‰ˆ RSC chunk æ‹¦æˆªè„šæœ¬...'));
    await page.addInitScript(() => {
      // åˆå§‹åŒ–æ”¶é›†å™¨
      window._rscChunkCollector = {
        chunks: [],
        productDetailFound: false,
        rawChunks: [], // ä¿å­˜åŸå§‹ chunk æ•°æ®ç”¨äºè°ƒè¯•
        hookAttempts: 0,
        hookSuccess: false,
        proxySetupCount: 0,
        failedParseExamples: []
      };
      
      console.log('[RSC Init] å¼€å§‹è®¾ç½®å¢å¼ºç‰ˆ RSC chunk æ‹¦æˆª...');
      
      // è®¾ç½® push hook çš„å‡½æ•°
      function setupPushHook(nextFArray) {
        console.log('[RSC Hook] è®¾ç½® push hook...');
        
        if (!nextFArray || typeof nextFArray.push !== 'function') {
          console.log('[RSC Hook] nextFArray æ— æ•ˆï¼Œè·³è¿‡ hook è®¾ç½®');
          return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»è¢« hook
        if (nextFArray._rscHooked) {
          console.log('[RSC Hook] æ•°ç»„å·²è¢« hookï¼Œè·³è¿‡');
          return true;
        }
        
        const originalPush = nextFArray.push;
        
        nextFArray.push = function(...args) {
          console.log('[RSC] __next_f.push è¢«è°ƒç”¨ï¼Œå‚æ•°æ•°é‡:', args.length);
          
          // ğŸŒŸ ä¿®å¤2: æ­£ç¡®å¤„ç† [chunkId, payload] æ•°ç»„æ ¼å¼
          if (args.length >= 2) {
            const chunkId = args[0];
            const payload = args[1];
            
            // ä¿å­˜åŸå§‹æ•°æ®ç”¨äºè°ƒè¯•
            window._rscChunkCollector.rawChunks.push({ chunkId, payload, timestamp: Date.now() });
            
            // å¤„ç†ä¸åŒç±»å‹çš„ payload
            let payloadStr = '';
            if (typeof payload === 'string') {
              payloadStr = payload;
            } else if (payload && typeof payload === 'object') {
              try {
                payloadStr = JSON.stringify(payload);
              } catch (e) {
                payloadStr = String(payload);
              }
            } else {
              payloadStr = String(payload || '');
            }
            
            console.log(`[RSC] æ”¶åˆ° chunk ${chunkId}, payload ç±»å‹: ${typeof payload}, é•¿åº¦: ${payloadStr.length}`);
            
            // ğŸŒŸ è°ƒè¯•ï¼šè¾“å‡ºå‰å‡ ä¸ªchunkçš„å†…å®¹æ ·æœ¬
            if (window._rscChunkCollector.rawChunks.length <= 5) {
              console.log(`[RSC Debug] Chunk ${chunkId} å†…å®¹é¢„è§ˆ:`, payloadStr.substring(0, 300) + '...');
            }
            
            // ğŸŒŸ ä¿®å¤3: æ£€æŸ¥ payload æ˜¯å¦åŒ…å«äº§å“ç›¸å…³æ•°æ®
            if (payloadStr && (payloadStr.includes('productDetail') || payloadStr.includes('imageGroups') || payloadStr.includes('variationAttributes') || payloadStr.includes('C25215200'))) {
              console.log(`[RSC] âœ“ Chunk ${chunkId} åŒ…å«äº§å“æ•°æ®`);
              window._rscChunkCollector.chunks.push({ chunkId, payload: payloadStr });
              
              // å°è¯•æå– productDetail æ•°æ®
              try {
                // RSC payload å¯èƒ½åŒ…å«è½¬ä¹‰å­—ç¬¦ï¼Œéœ€è¦å¤„ç†
                let cleanPayload = payloadStr;
                if (cleanPayload.includes('\\u003c')) {
                  cleanPayload = cleanPayload.replace(/\\u003c/g, '<');
                }
                if (cleanPayload.includes('\\"')) {
                  cleanPayload = cleanPayload.replace(/\\\"/g, '"');
                }
                
                // ğŸŒŸ ä¿®æ­£ï¼šä½¿ç”¨æ›´ç²¾å‡†çš„æ­£åˆ™åŒ¹é…å®Œæ•´çš„ productDetail å¯¹è±¡ï¼ˆåŒ…å«åµŒå¥—ç»“æ„ï¼‰
                const productDetailMatch = cleanPayload.match(/"productDetail"\s*:\s*(\{(?:[^{}]|\{[^{}]*\})*\})/); 
                
                if (productDetailMatch) {
                  const productDetailStr = '{"productDetail":' + productDetailMatch[1] + '}';
                  const productDetail = JSON.parse(productDetailStr);
                  
                  if (productDetail.productDetail && (productDetail.productDetail.imageGroups || productDetail.productDetail.variationAttributes)) {
                    window._rscChunkCollector.productDetailFound = true;
                    window._rscChunkCollector.productDetail = productDetail.productDetail;
                    console.log('[RSC] âœ“ æˆåŠŸè§£æ productDetail:', {
                      hasImageGroups: !!productDetail.productDetail.imageGroups,
                      imageGroupsCount: (productDetail.productDetail.imageGroups || []).length,
                      hasVariationAttributes: !!productDetail.productDetail.variationAttributes,
                      variationAttributesCount: (productDetail.productDetail.variationAttributes || []).length
                    });
                  }
                }
              } catch (e) {
                console.log(`[RSC] è§£æ chunk ${chunkId} å¤±è´¥:`, e.message);
                // ä¿å­˜è§£æå¤±è´¥çš„ payload ç‰‡æ®µç”¨äºè°ƒè¯•
                const snippet = payloadStr.length > 400 ? 
                  payloadStr.substring(0, 200) + '...' + payloadStr.substring(payloadStr.length - 200) :
                  payloadStr;
                window._rscChunkCollector.failedParseExamples.push({ chunkId, snippet, error: e.message });
              }
            }
          } else if (args.length === 1) {
            // å¤„ç†å•å‚æ•°æƒ…å†µ
            const data = args[0];
            let dataStr = '';
            if (typeof data === 'string') {
              dataStr = data;
            } else if (data && typeof data === 'object') {
              try {
                dataStr = JSON.stringify(data);
              } catch (e) {
                dataStr = String(data || '');
              }
            } else {
              dataStr = String(data || '');
            }
            
            window._rscChunkCollector.rawChunks.push({ chunkId: 'unknown', payload: dataStr, timestamp: Date.now() });
            console.log(`[RSC] æ”¶åˆ°å•å‚æ•°æ•°æ®ï¼Œç±»å‹: ${typeof data}, é•¿åº¦: ${dataStr.length}`);
          }
          
          // è°ƒç”¨åŸå§‹æ–¹æ³•
          return originalPush.apply(this, args);
        };
        
        // æ ‡è®°ä¸ºå·² hook
        nextFArray._rscHooked = true;
        console.log('[RSC Hook] âœ“ Push hook è®¾ç½®æˆåŠŸ');
        return true;
      }
      
      // ğŸŒŸ æ–°å¢ï¼šä½¿ç”¨ defineProperty ä»£ç† self.__next_f
      function setupNextFProxy() {
        window._rscChunkCollector.proxySetupCount++;
        console.log(`[RSC Proxy] è®¾ç½® __next_f ä»£ç† #${window._rscChunkCollector.proxySetupCount}`);
        
        // ç¡®ä¿ self å­˜åœ¨
        if (!window.self) {
          window.self = window;
          console.log('[RSC Proxy] åˆ›å»º window.self');
        }
        
        // è·å–å½“å‰çš„ __next_f å€¼ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        let currentNextF = window.self.__next_f || [];
        
        // å¯¹å½“å‰æ•°ç»„è®¾ç½® hook
        if (Array.isArray(currentNextF)) {
          setupPushHook(currentNextF);
        }
        
        // ä½¿ç”¨ defineProperty ä»£ç† __next_f
        try {
          Object.defineProperty(window.self, '__next_f', {
            get: function() {
              return currentNextF;
            },
            set: function(newValue) {
              console.log('[RSC Proxy] __next_f è¢«é‡æ–°èµ‹å€¼ï¼Œç±»å‹:', typeof newValue, 'é•¿åº¦:', Array.isArray(newValue) ? newValue.length : 'N/A');
              
              // æ›´æ–°å½“å‰å€¼
              currentNextF = newValue || [];
              
              // ä¸ºæ–°æ•°ç»„è®¾ç½® hook
              if (Array.isArray(currentNextF)) {
                setupPushHook(currentNextF);
                window._rscChunkCollector.hookSuccess = true;
              }
            },
            configurable: true
          });
          
          console.log('[RSC Proxy] âœ“ __next_f ä»£ç†è®¾ç½®æˆåŠŸ');
          return true;
        } catch (e) {
          console.log('[RSC Proxy] ä»£ç†è®¾ç½®å¤±è´¥:', e.message);
          return false;
        }
      }
      
      // ç«‹å³è®¾ç½®ä»£ç†
      const proxySuccess = setupNextFProxy();
      
      if (proxySuccess) {
        window._rscChunkCollector.hookSuccess = true;
        console.log('[RSC Init] âœ“ ä»£ç†å’Œ Hook è®¾ç½®æˆåŠŸ');
      } else {
        // å¦‚æœä»£ç†è®¾ç½®å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿæ–¹æ³•
        console.log('[RSC Init] ä»£ç†è®¾ç½®å¤±è´¥ï¼Œå›é€€åˆ°ä¼ ç»Ÿ hook æ–¹æ³•');
        
        // ä¼ ç»Ÿ Hook å°è¯•
        function setupTraditionalHook() {
          window._rscChunkCollector.hookAttempts++;
          console.log(`[RSC Init] ä¼ ç»Ÿ Hook å°è¯• #${window._rscChunkCollector.hookAttempts}`);
          
          if (!window.self.__next_f) {
            window.self.__next_f = [];
            console.log('[RSC Init] åˆ›å»º window.self.__next_f');
          }
          
          if (Array.isArray(window.self.__next_f)) {
            setupPushHook(window.self.__next_f);
            window._rscChunkCollector.hookSuccess = true;
          }
        }
        
        // ç«‹å³å°è¯•ä¼ ç»Ÿ hook
        setupTraditionalHook();
        
        // å®šæ—¶é‡è¯•ä¼ ç»Ÿ hook
        const retryInterval = setInterval(() => {
          if (!window._rscChunkCollector.hookSuccess && window._rscChunkCollector.hookAttempts < 5) {
            setupTraditionalHook();
          } else {
            clearInterval(retryInterval);
          }
        }, 100);
      }
      
      console.log('[RSC Init] å¢å¼ºç‰ˆ Hook æ³¨å…¥å®Œæˆï¼Œç­‰å¾… chunk æ•°æ®...');
    });
    
    // è®¿é—®é¡µé¢
    console.log(colors.blue('ğŸ“„ è®¿é—®äº§å“é¡µé¢...'));
    console.log(colors.gray(`âš ï¸ ç¡®ä¿ä½¿ç”¨æŒ‡å®šURL: ${url}`));
    await page.goto(url, { 
      waitUntil: 'domcontentloaded',
      timeout: 45000
    });
    
    // ç­‰å¾…é¡µé¢æ¸²æŸ“å’Œ RSC æ•°æ®åŠ è½½
    await page.waitForTimeout(8000);
    
    // æ£€æŸ¥ RSC Hook çŠ¶æ€ + ç½‘ç«™æ¶æ„è¯Šæ–­
    const hookStatus = await page.evaluate(() => {
      if (!window._rscChunkCollector) return { error: 'æ”¶é›†å™¨æœªåˆå§‹åŒ–' };
      
      // è¯Šæ–­ç½‘ç«™ä½¿ç”¨çš„æŠ€æœ¯æ ˆ
      const diagnostics = {
        // Next.js æ£€æµ‹
        hasNextJs: !!(window.__NEXT_DATA__ || window.__NEXT_LOADED_PAGES__ || window.__NEXT_P),
        nextData: !!window.__NEXT_DATA__,
        nextBuildId: window.__NEXT_DATA__ ? window.__NEXT_DATA__.buildId : null,
        
        // React æ£€æµ‹
        hasReact: !!(window.React || document.querySelector('[data-reactroot]')),
        
        // å…¶ä»–æ¡†æ¶æ£€æµ‹
        hasVue: !!window.Vue,
        hasAngular: !!window.angular,
        hasJQuery: !!window.jQuery,
        
        // æŸ¥æ‰¾å¯èƒ½çš„æ•°æ®æº
        scriptTags: Array.from(document.querySelectorAll('script')).length,
        jsonScripts: Array.from(document.querySelectorAll('script[type="application/json"]')).length,
        nextScripts: Array.from(document.querySelectorAll('script')).filter(s => s.src && s.src.includes('_next')).length,
        
        // æ£€æŸ¥ window å¯¹è±¡ä¸­çš„æ•°æ®
        windowKeys: Object.keys(window).filter(k => k.includes('product') || k.includes('data') || k.includes('config')).slice(0, 10),
        
        // æ£€æŸ¥æ˜¯å¦æœ‰äº§å“æ•°æ®åœ¨ DOM ä¸­
        hasProductData: !!document.querySelector('[data-product]') || 
                       !!document.querySelector('.product-detail') ||
                       !!document.querySelector('#product-data') ||
                       document.body.innerHTML.includes('productDetail'),
        
        // æ£€æŸ¥å¯èƒ½çš„ API è°ƒç”¨
        hasJsonLd: Array.from(document.querySelectorAll('script[type="application/ld+json"]')).length
      };
      
      return {
        hookAttempts: window._rscChunkCollector.hookAttempts,
        hookSuccess: window._rscChunkCollector.hookSuccess,
        rawChunksCount: window._rscChunkCollector.rawChunks.length,
        nextFExists: !!window.self.__next_f,
        nextFLength: window.self.__next_f ? window.self.__next_f.length : 0,
        nextFType: typeof window.self.__next_f,
        diagnostics: diagnostics
      };
    });
    
    console.log(colors.blue('ğŸ” RSC Hook çŠ¶æ€æ£€æŸ¥:'));
    console.log(colors.gray(`  Hook å°è¯•æ¬¡æ•°: ${hookStatus.hookAttempts}`));
    console.log(colors.gray(`  Hook æ˜¯å¦æˆåŠŸ: ${hookStatus.hookSuccess}`));
    console.log(colors.gray(`  __next_f æ˜¯å¦å­˜åœ¨: ${hookStatus.nextFExists}`));
    console.log(colors.gray(`  __next_f é•¿åº¦: ${hookStatus.nextFLength}`));
    console.log(colors.gray(`  åŸå§‹ chunks æ•°é‡: ${hookStatus.rawChunksCount}`));
    
    console.log(colors.blue('\nğŸ—ï¸  ç½‘ç«™æ¶æ„è¯Šæ–­:'));
    const diag = hookStatus.diagnostics;
    console.log(colors.gray(`  Next.js: ${diag.hasNextJs ? 'âœ“' : 'âœ—'} (buildId: ${diag.nextBuildId || 'none'})`));
    console.log(colors.gray(`  __NEXT_DATA__: ${diag.nextData ? 'âœ“' : 'âœ—'}`));
    console.log(colors.gray(`  React: ${diag.hasReact ? 'âœ“' : 'âœ—'}`));
    console.log(colors.gray(`  Vue: ${diag.hasVue ? 'âœ“' : 'âœ—'}`));
    console.log(colors.gray(`  jQuery: ${diag.hasJQuery ? 'âœ“' : 'âœ—'}`));
    console.log(colors.gray(`  è„šæœ¬æ ‡ç­¾æ•°: ${diag.scriptTags}`));
    console.log(colors.gray(`  Next.js è„šæœ¬: ${diag.nextScripts}`));
    console.log(colors.gray(`  JSON è„šæœ¬: ${diag.jsonScripts}`));
    console.log(colors.gray(`  JSON-LD: ${diag.hasJsonLd}`));
    console.log(colors.gray(`  äº§å“æ•°æ®åœ¨DOM: ${diag.hasProductData ? 'âœ“' : 'âœ—'}`));
    console.log(colors.gray(`  ç–‘ä¼¼æ•°æ®é”®: [${diag.windowKeys.join(', ')}]`));
    
    // å¦‚æœä¸æ˜¯ Next.jsï¼Œå°è¯•å…¶ä»–æ•°æ®æå–æ–¹æ³•
    if (!diag.hasNextJs || !diag.nextData) {
      console.log(colors.yellow('\nâš ï¸  æ£€æµ‹åˆ°é Next.js æ¶æ„ï¼Œå°è¯•å¤‡ç”¨æ•°æ®æå–æ–¹æ³•...'));
      
      const alternativeData = await page.evaluate(() => {
        // æŸ¥æ‰¾ JSON-LD ç»“æ„åŒ–æ•°æ®
        const jsonLdScripts = Array.from(document.querySelectorAll('script[type="application/ld+json"]'));
        const jsonLdData = jsonLdScripts.map(script => {
          try {
            return JSON.parse(script.textContent);
          } catch (e) {
            return null;
          }
        }).filter(data => data);
        
        // æŸ¥æ‰¾å†…è” JSON æ•°æ®
        const allScripts = Array.from(document.querySelectorAll('script:not([src])'));
        const inlineData = [];
        
        allScripts.forEach(script => {
          const content = script.textContent || '';
          if (content.includes('productDetail') || content.includes('imageGroups') || content.includes('variationAttributes')) {
            inlineData.push({
              type: 'inline-script',
              length: content.length,
              hasProductDetail: content.includes('productDetail'),
              hasImageGroups: content.includes('imageGroups'),
              hasVariationAttributes: content.includes('variationAttributes'),
              snippet: content.substring(0, 200) + '...'
            });
          }
        });
        
        // æŸ¥æ‰¾å¯èƒ½çš„äº§å“æ•°æ® API endpoint
        const possibleEndpoints = [];
        allScripts.forEach(script => {
          const content = script.textContent || '';
          const apiMatches = content.match(/['"](\/api\/[^'"]*)['"]|['"](\/products?\/[^'"]*)['"]|['"](\/v\d+\/[^'"]*)['"]/);
          if (apiMatches) {
            possibleEndpoints.push(...apiMatches.filter(m => m).slice(1));
          }
        });
        
        return {
          jsonLdCount: jsonLdData.length,
          jsonLdTypes: jsonLdData.map(d => d['@type']).filter(t => t),
          inlineDataScripts: inlineData.length,
          inlineScriptsWithProductData: inlineData,
          possibleApiEndpoints: [...new Set(possibleEndpoints)]
        };
      });
      
      console.log(colors.blue('\nğŸ” å¤‡ç”¨æ•°æ®æºæ‰«æç»“æœ:'));
      console.log(colors.gray(`  JSON-LD æ•°æ®: ${alternativeData.jsonLdCount} ä¸ª`));
      console.log(colors.gray(`  JSON-LD ç±»å‹: [${alternativeData.jsonLdTypes.join(', ')}]`));
      console.log(colors.gray(`  å†…è”è„šæœ¬å«äº§å“æ•°æ®: ${alternativeData.inlineDataScripts}`));
      console.log(colors.gray(`  å¯èƒ½çš„APIç«¯ç‚¹: [${alternativeData.possibleApiEndpoints.join(', ')}]`));
      
      if (alternativeData.inlineScriptsWithProductData.length > 0) {
        console.log(colors.yellow('\nğŸ“ å‘ç°åŒ…å«äº§å“æ•°æ®çš„å†…è”è„šæœ¬:'));
        alternativeData.inlineScriptsWithProductData.forEach((script, i) => {
          console.log(colors.gray(`  è„šæœ¬ ${i+1}: é•¿åº¦=${script.length}, productDetail=${script.hasProductDetail}, imageGroups=${script.hasImageGroups}`));
          console.log(colors.gray(`    é¢„è§ˆ: ${script.snippet}`));
        });
      }
    }
    
    // ğŸŒŸ éªŒè¯é¡µé¢æ ‡é¢˜ï¼Œç¡®è®¤ä¸æ˜¯404é¡µé¢
    const pageTitle = await page.title();
    console.log(colors.blue(`ğŸ“„ é¡µé¢æ ‡é¢˜: ${pageTitle}`));
    
    if (pageTitle.includes('404') || pageTitle.includes('Page Not Found') || pageTitle.includes('Not Found')) {
      throw new Error(`âŒ é¡µé¢ä¸º404é”™è¯¯é¡µé¢: ${pageTitle}`);
    }
    
    console.log(colors.green('âœ“ é¡µé¢è®¿é—®æˆåŠŸï¼Œç¡®è®¤ä¸ºçœŸå®å•†å“é¡µé¢'));
    
    // ğŸŒŸ æ–°çš„æ•°æ®æå–æµç¨‹ï¼ˆä¿®å¤ç‰ˆï¼‰
    console.log(colors.magenta('\n=== å¼€å§‹æ–°æ•°æ®æå–æµç¨‹ ==='));
    
    // 1. æå–çœŸå®é¡µé¢æ•°æ®
    const realData = await extractRealProductData(page, productId);
    
<<<<<<< HEAD
    // 2. åˆå¹¶çœŸå®æ•°æ®å¹¶ç”ŸæˆåŠ¨æ€å˜ä½“
=======
    // 2. æ„å»ºæœ€ç»ˆäº§å“æ•°æ®ï¼ˆåªä¾èµ–çœŸå®æ•°æ®ï¼‰
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
    const productData = buildFinalProductData(realData, productId);
    
    console.log(colors.magenta('=== æ•°æ®æå–å®Œæˆ ===\n'));
    

    // ğŸŒŸ æ„å»ºé£ä¹¦è„šæœ¬å®Œå…¨å…¼å®¹çš„æœ€ç»ˆæ ¼å¼ï¼ˆä¿®å¤ç‰ˆï¼‰
    const result = {
      // æŠ“å–ä¿¡æ¯
      scrapeInfo: {
        timestamp: new Date().toISOString(),
        version: "5.0.0-fixed",
        url: url,
        productId: productId,
        totalVariants: productData.variants.length,
        totalColors: productData.colors.length,
        totalSizes: productData.sizes.length,
        totalImages: Object.values(productData.imagesByColor).reduce((total, images) => total + images.length, 0),
        processingTimeMs: Date.now() - startTime,
        dataSources: productData.dataSources
      },
      
      // ğŸŒŸ é£ä¹¦è„šæœ¬æœŸæœ›çš„ product å¯¹è±¡ç»“æ„
      product: {
        productId: productData.productId,
        title: productData.title,
        productUrl: argv.url, // ğŸŒŸ ç¡®ä¿ä½¿ç”¨æŒ‡å®šURLï¼Œä¸è¢«å…¶ä»–é€»è¾‘æ”¹å†™
        description: productData.description,
        brand: productData.brand,
        category: '',
        tags: [],
        mainImage: productData.rawImages && productData.rawImages.length > 0 ? productData.rawImages[0] : '',
        detailUrl: argv.url, // ğŸŒŸ ç¡®ä¿ä½¿ç”¨æŒ‡å®šURL
        // ğŸŒŸ ç”¨æˆ·è¦æ±‚ï¼šproduct.sizeChart å¿…é¡»å­˜åœ¨
        sizeChart: productData.sizeChart || { headers: [], rows: [] }
      },
      
<<<<<<< HEAD
      // ğŸŒŸ GLM-4.6: ç”¨æˆ·æœŸæœ›çš„ variants ç»“æ„
      variants: {
        colors: productData.colors || [], // å®é™…æå–çš„é¢œè‰²åˆ—è¡¨
        sizes: productData.sizes || [],   // å®é™…æå–çš„å°ºç åˆ—è¡¨
        list: productData.variants.map(variant => ({
          variantId: variant.variantId,
          colorName: variant.colorName,
          colorCode: variant.colorCode,
          sizeName: variant.sizeName,
          sizeCode: variant.sizeCode,
          availability: variant.availability,
          sku: variant.sku,
          priceJPY: variant.priceJPY
        }))
      },
=======
      // å˜ä½“æ•°æ®ï¼ˆåŠ¨æ€ç”Ÿæˆï¼‰
      variants: productData.variants,
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
      
      // ä¿æŒå‘åå…¼å®¹çš„å­—æ®µ
      colors: productData.colors,
      sizes: productData.sizes,
      
      // å°ºç è¡¨ï¼ˆçœŸå®æå–ï¼‰
      sizeChart: productData.sizeChart,
      
      // å›¾ç‰‡æ•°æ®ï¼ˆæŒ‰é¢œè‰²åˆ†ç»„ï¼‰
      images: {
        byColor: productData.imagesByColor,
        all: productData.rawImages,
        metadata: productData.colorMetadata
      }
    };
    
    // ç”Ÿæˆè¾“å‡ºæ–‡ä»¶å
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').replace('T', '_').slice(0, -5);
    const outputFileName = `product_details_${productId}_${timestamp}.json`;
    const outputPath = path.resolve(OUTPUT_DIR, outputFileName);
    
    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    await ensureDir(path.dirname(outputPath));
    
    // ä¿å­˜ç»“æœ
    await fs.writeFile(outputPath, JSON.stringify(result, null, 2), 'utf-8');
    
    // è¾“å‡ºæˆåŠŸä¿¡æ¯ï¼ˆä¿®å¤ç‰ˆï¼‰
    console.log('');
    console.log(colors.green('ğŸ‰ GLM-4.6 é‡å†™ç‰ˆæŠ“å–å®Œæˆï¼'));
    console.log(colors.green(`âœ“ äº§å“ID: ${productId}`));
    console.log(colors.green(`âœ“ é¢œè‰²æ•°ç»„: [${result.colors.join(', ')}] (${result.colors.length}ä¸ª)`));
    console.log(colors.green(`âœ“ å°ºç æ•°ç»„: [${result.sizes.join(', ')}] (${result.sizes.length}ä¸ª)`));
    console.log(colors.green(`âœ“ å˜ä½“æ€»æ•°: ${result.variants.length} (ç°æœ‰é€»è¾‘)`));
    console.log(colors.green(`âœ“ å›¾ç‰‡æ€»æ•°: ${result.scrapeInfo.totalImages}`));
    console.log(colors.green(`âœ“ æè¿°é•¿åº¦: ${result.product.description.length} å­—ç¬¦`));
    console.log(colors.green(`âœ“ å°ºç è¡¨: ${result.sizeChart ? 'å·²æå–' : 'æœªæ‰¾åˆ°'}`));
    console.log(colors.green(`âœ“ æ•°æ®æº: ${result.scrapeInfo.dataSources.join(', ')}`));
    console.log(colors.green(`âœ“ å¤„ç†æ—¶é—´: ${((Date.now() - startTime) / 1000).toFixed(2)}s`));
    console.log(colors.blue(`ğŸ“ è¾“å‡ºæ–‡ä»¶: ${outputPath}`));
    
    // æ ¸å¿ƒæŒ‡æ ‡æ£€æŸ¥ï¼ˆGLM-4.6ç‰ˆæœ¬ï¼‰
    if (result.colors.length > 0) {
      console.log(colors.green(`âœ“ é¢œè‰²æ•°ç»„æå–æˆåŠŸï¼š${result.colors.length}ä¸ªé¢œè‰²`));
    } else {
      console.log(colors.red('âš ï¸ é¢œè‰²æ•°ç»„ä¸ºç©º'));
    }
    
    if (result.sizes.length > 0) {
      console.log(colors.green(`âœ“ å°ºç æ•°ç»„æå–æˆåŠŸï¼š${result.sizes.length}ä¸ªå°ºç `));
    } else {
      console.log(colors.red('âš ï¸ å°ºç æ•°ç»„ä¸ºç©º'));
    }
    
    if (result.product.description.length > 0) {
      console.log(colors.green('âœ“ å•†å“è¯´æ˜æå–æˆåŠŸ'));
    } else {
      console.log(colors.red('âš ï¸ å•†å“è¯´æ˜æœªæå–'));
    }
    
    return outputPath;
    
  } catch (error) {
    console.error('');
    console.error(colors.red('ğŸ’¥ æŠ“å–å¤±è´¥:'));
    console.error(colors.red(error.message));
    
    if (error.stack) {
      console.error('');
      console.error(colors.gray('Stack trace:'));
      console.error(colors.gray(error.stack));
    }
    
    throw error;
  } finally {
    // æ¸…ç†èµ„æº
    if (browser) {
      await browser.close();
    }
    
  }
}

/**
 * ä¸»å‡½æ•°
 */
async function main() {
  try {
    const outputPath = await scrapeProductDetail();
    
    console.log('');
    console.log(colors.blue('ğŸ’¡ ä¸‹ä¸€æ­¥æ“ä½œ:'));
    console.log(colors.gray(`python3 CallawayJP/scripts/update_feishu_product_details.py --input "${outputPath}"`));
    console.log('');
    
    process.exit(0);
  } catch (error) {
    console.error(colors.red(`\nç¨‹åºæ‰§è¡Œå¤±è´¥: ${error.message}`));
    process.exit(1);
  }
}

// æ‰§è¡Œä¸»å‡½æ•°
if (require.main === module) {
  main();
}

module.exports = {
  scrapeProductDetail,
  extractRealProductData,
<<<<<<< HEAD
  createDynamicVariants,
  buildFinalProductData,
  processImagesWithVariantGrouping
=======
  buildFinalProductData
>>>>>>> e1e4513 (refactor: ä¼˜åŒ–CallawayJPäº§å“æŠ“å–è„šæœ¬æ¶æ„)
};
